{"meta":{"title":"myBlog","subtitle":null,"description":null,"author":"tang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-05-16T08:31:35.039Z","updated":"2019-05-16T08:31:35.039Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-05-15T02:30:37.634Z","updated":"2018-10-11T14:37:33.752Z","comments":true,"path":"gallery/index.html","permalink":"http://yoursite.com/gallery/index.html","excerpt":"","text":""},{"title":"","date":"2019-05-20T03:01:09.133Z","updated":"2019-05-20T03:01:09.133Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"最美的期待,对未来的期许!"},{"title":"����","date":"2019-05-15T04:39:04.000Z","updated":"2019-05-15T03:42:57.007Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Sevlet知识","slug":"Sevlet","date":"2019-10-12T07:24:54.826Z","updated":"2019-10-16T09:38:56.145Z","comments":true,"path":"2019/10/12/Sevlet/","link":"","permalink":"http://yoursite.com/2019/10/12/Sevlet/","excerpt":"servlet具体的运行过程浏览器输入地址,与Tomcat建立连接,发送请求,Tomcat中的HTTPRequest解析请求(解析请求行(包括请求方式,请求路径,协议版本),消息头,消息正文,根据路径url部分找到web.xml,反射机制解析servlet请求业务,请求方式有get和post请求,get方式能在消息头解析到,post需要在消息正文中解析),创建servlet业务,通过service()方法,再通过request对象获取数据,写入数据到response对象中(HTTPResponse中响应状态行,响应头,响应正文,状态行设置状态代码,响应头同Httpcontext中的SAXreader解析对应介质类型映射,发送响应正文),发送响应给浏览器,浏览器解析响应数据包,显示页面.","text":"servlet具体的运行过程浏览器输入地址,与Tomcat建立连接,发送请求,Tomcat中的HTTPRequest解析请求(解析请求行(包括请求方式,请求路径,协议版本),消息头,消息正文,根据路径url部分找到web.xml,反射机制解析servlet请求业务,请求方式有get和post请求,get方式能在消息头解析到,post需要在消息正文中解析),创建servlet业务,通过service()方法,再通过request对象获取数据,写入数据到response对象中(HTTPResponse中响应状态行,响应头,响应正文,状态行设置状态代码,响应头同Httpcontext中的SAXreader解析对应介质类型映射,发送响应正文),发送响应给浏览器,浏览器解析响应数据包,显示页面. servlet1.servlet:sun公司制定的一种用来扩展web服务器功能的组件规范web服务器只能处理静态资源的请求,即需要事先将html文档准备好,并存到web服务器上,不能处理动态资源的请求,需要servlet扩展. 2.组件和容器组件:符合规范,具有部分功能,且需要部署到相应的容器里面才能运行的软件模块,servlet就是一个组件容器:符合规范,为组件提供运行环境的程序.servlet容器为servlet提供了相应的运行环境(即网络相关的服务),Tomcat是一个符合servlet规范的容器 3.http协议:一种网络应用层协议规定浏览器如何与web服务器之间进行通信及响应的数据包的结构TCP/IP:传输层和网络层协议,将数据包可靠地传递(用socket传递接收数据包会丢包,所以需要一些协议进行进一步解析传递) 4.浏览器与web服务器之间如何通信?建立连接,发送请求,发送响应,关闭连接,若浏览器要再次发送请求,需要重写建立新的连接,及”一次请求,一次连接”.优点:web服务器可以利用有限的连接为尽可能多的请求服务 5.数据包的结构请求数据包:a.请求行(请求方式,请求资源路径,协议版本)b.若干消息头(是一个键值对,使用:隔开),浏览器与web服务器,可以通过发送一些消息头来传递一些特定消息,如浏览器可以发送”user-agent”,消息头告诉服务器,浏览器的类型和版本.c.实体内容(消息正文):只有当请求方式为post时,实体内容才会有数据响应数据包:a.状态行(协议版本,状态代码,状态描述),状态码是一个三位数字,描述服务器请求的一个状态.b.响应头,发送一些响应头,如”Content-Type”告诉浏览器,服务器返回的数据类型和编码.c.实体内容,程序的处理结果,浏览器解析出来,生成相应的页面 6.两种请求方式 ajax技术get请求发get请求情况:在浏览器输入某个地址 点击链接 表单默认的提交方式特点:将请求参数显示在浏览器地址栏,不安全(一些网络设备会记录请求地址)会将请求参数添加到请求行(请求行只能存放2k左右数据),只能提交少量数据post请求发post请求情况:将表单的method属性设置为post特点:不会将请求参数显示在浏览器地址栏,相对安全(http协议对数据包并不会加密处理,所以需要用http的加密),会将请求参数添加到实体内容里面,可以提交大量数据. 7.重定向服务器通知浏览器向某个地址发送请求(服务器可以通过302状态和location消息头,该消息头的值是一个地址,为重定向地址),浏览器收到后,会立即向重定向地址发送请求.如何重定向:response.sendRedirect(String url) url是重定向地址特点:重定向地址是任意的,重定向之后浏览器地址栏的地址会发生变化 JSPsun公司制定的一种服务器端的动态页面技术规范,(因为使用servlet虽然也可以生成动态页面,但由于反射,需要使用大量out.println语句,并且不利于页面的维护,若要修改页面,需要修改servlet代码,所以制定了jsp)jsp是以.jsp为后缀的文件,该文件主要由html和少量的java代码组成,容器会将这个文件自动转成servlet然后执行,本质是一个servlet. 1.写jsp的步骤(1)写.jsp为后缀的文件(2)在这个文件中,可以使用如下元素:html(css,js)直接写即可,java代码片段&lt;%java代码%&gt;,jsp表达式&lt;%=java表达式%&gt;隐含对象:可以直接使用的对象,如out,request,response,application,session,exception,pageContext,page(jsp实例本身),config因容器在生成对应的servlet源代码时,会自动添加获得这些对象的代码.指令:告诉容器将jsp转成一个servlet时,额外做一些从处理,如导包语法:&lt;%@指令名 属性=值%&gt;page指令:import属性用于指定要导入的包名&lt;%@page import=”java.util. , java.text. “%&gt;a.contentType属性:用于设置response.setContentType方法的内容b.pageEncoding属性:用来告诉容器在读取jsp文件的内容时使用指定字符集来解码c.session属性:缺省值是true,若值是false,则容器不再添加获得session对象的代码,即 不能使用session隐含对象.d.errorPage属性:用来指定一个异常处理页面,当jsp运行发送异常,则容器会调用异常页 面处理f.isErrorPage属性:缺省值是false,若值是true,就可以使用exception隐含对象 (exception对象用于获得异常的一个简短的描述) 2.include指令file属性:用于指定被包含的文件名.(容器会将file属性指定的文件的内容插入到该指令所在的位置,被包含的jsp并不会真正执行,没有对应的servlet) 3.jsp执行过程(1)容器将jsp转换成一个servlet(html–&gt;service方法里面使用out.weite输出)注:out.println将null直接输出,out.write方法会将null转换成””输出 &lt;% %&gt; --&gt; service方法里,照搬 &lt;%= %&gt; --&gt; service方法中,使用out.print方法输出 &lt;%! %&gt; --&gt; 给servlet增加了新的属性或方法 (2)容器再调用该servlet,容器会将该servlet先编译,然后实例化,初始化,调用,销毁. 转发一个web组件将未完成的处理交给另外一个web组件继续做.web组件是servlet和jsp的总称,通常是一个servlet获得数据之后转交给另外一个jsp来展现. 1.转发过程(1)将数据绑定到request对象上 request.setAttribute(String name,Object obj); name:绑定名 obj:绑定值 ` (2)获得转发器RequestDispatcher rd = request.getRequestDistinct(String url);RequestDispatch是一个接口,该方法会返回一个符合该接口要求的对象,该对象为转发器转发的本质是一个web组件通知转发器会调用另外一个web组件,可以将转发器看做一个媒介,通过媒介可以通知容器去调另一个web组件.url是转发的目的地,通常是一个jsp(3)转发rd.forward(request,response); 依据绑定名获得绑定值,若绑定值不在,返回nullrequest.getAttribute(String name); 2.特点转发之后,浏览器的地址栏的地址是不变的;转发的目的地有限制,要求属于同一个web应用. 3.比较转发和重定向(1)转发可以共享request,重定向不行(容器收到请求之后,会立即创建request和response对象,一旦响应发送完毕,会立即销毁这两个对象,也就是说request和response对象的生成时间是一次请求和响应期间存在;转发是一次请求,重定向是二次请求)(2)转发的浏览器地址栏的地址没有变化,重定向有变化(3)转发的目的地有限制(要求同一个应用),重定向没有任何限制 状态管理1.状态管理将浏览器与web服务器之间多次交互当做一个整体来处理,并且将多次交互所涉及的数据(即状态)保存下来. 2.如何进行状态管理(1)将状态保存在浏览器端(cookie)(2)将状态保存在服务器端(session会话) 2.cookiecookie:服务器临时存放在浏览器端的少量数据,用于跟踪用户状态.cookie工作原理:当浏览器访问服务器时,服务器将少量数据以set-cookie消息头的形式发给浏览器,浏览器会保存下来;当浏览器再次访问服务器时,会将之前保存的这些数据以cookie消息头的形式发送给服务器. 3.如何添加cookieCookie c = new Cookie(String name,String value);response.addCookie(c);name–cookie的名称 value–cookie的值 4.如何读取cookieCookie[] request.getCookies();该方法有可能返回nullString cookie.getName();String cookie.getValue(); 5.生存时间问题(1)默认情况下,浏览器会将cookie保存在内存里面,浏览器如果关闭,则cookie会被删除.(2)可以调用setMaxAge方法来设置cookie的生存时间. cookie.setMaxAge(int seconds); 单位是秒 seconds &gt; 0:浏览器会将cookie保存在硬盘上(一般是文件的形式),超过指定的时 间,cookie会被删除. seconds &lt; 0:默认情况(即保存到内存里面) seconds = 0:删除cookie 如,要删除一个名称为username的cookie Cookie c = new Cookie(“username”,””); c.setMaxAge(0); response.addCookie(c);//同名的cookie会被覆盖达到修改的目的 servlet的生命周期生命周期:Servlet容器如何创建servlet实例,如何对其进行初始化操作,如何调用其方法来处理请求,以及如何销毁其实例的整个过程,也可以说即容器时如何管理servlet. 生命周期分成哪几个阶段1.实例化:容器调用servlet的构造器,创建servlet实例 实例化时间:默认情况下,容器只有收到请求后,才会创建servlet实例(容器只会创建一个servlet实例) 在添加适当配置后,可以让容器启动后,立即创建servlet. &lt;!--配置启动加载 参数值是一个大于等于零的整数,值越小越优先被创建--> &lt;load-on-startup>1&lt;/load-on-startup> 2.初始化容器在创建好servlet实例后,会调用该实例的init(ServletConfig)方法.(该方法只会执行1次)GenricServlet已经提供了init(ServletConfig config)方法的实现.该方法实现:将容器传递过来的ServletConfig对象保存下来,且提供了getServletConfig方法来获得该对象,另外,该方法还调用了一个init()方法,作为开发人员,若要扩展,只需要重写override init()方法即可. ServletConfig提供了一些实用方法,如读取初始化参数的方法. company 码多多 3.就绪(调用)容器在收到请求之后,会调用servlet实例的service方法处理请求.HttpServlet已经提供了service方法的实现.该方法实现:依据请求类型调用对应的doXXX方法,如get请求调用doGet方法,post请求调用doPost方法.doXXX方法只是简单的抛出一个异常.在开发servlet时,有两个选择,一是直接重写Httpservlet的service方法,或者重写HttpServlet的doGet和doPost方法. 4.销毁容器在删除servlet实例之前,会调用该实例的destory方法.(该方法只会执行一次)该方法的实现为空(什么都没有做),开发人员可以override的destory方法来扩展.","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Sevlet","slug":"Sevlet","permalink":"http://yoursite.com/tags/Sevlet/"},{"name":"Java知识","slug":"Java知识","permalink":"http://yoursite.com/tags/Java知识/"}]},{"title":"Hadoop","slug":"Hadoop知识","date":"2019-10-12T01:43:45.176Z","updated":"2019-10-12T06:40:23.672Z","comments":true,"path":"2019/10/12/Hadoop知识/","link":"","permalink":"http://yoursite.com/2019/10/12/Hadoop知识/","excerpt":"Hadoop相关知识基础知识Hadoop是一个用Java编写的Apache开源框架,用来处理分布式大型数据集.","text":"Hadoop相关知识基础知识Hadoop是一个用Java编写的Apache开源框架,用来处理分布式大型数据集. Hadoop架构框架包括四个模块:1.Hadoop Common:其他Hadoop模块所需的Java库和实用程序,这些库提供文件系统和操作系统级抽象,并包含启动Hadoop所需的Java文件和脚本.2.Hadoop YARN:用于作业调度和集群资源管理的框架.3.HDFS:分布式文件系统.4.Hadoop MapReduce:基于YARN处理大数据集的系统. MapReduceMapReduce是一个软件框架,用于轻松编写应用程序,以可靠,容错的方式在大型集群硬件上并行处理大量数据.实际Hadoop程序执行两个不同任务:1.The Map Task2.The Reduce Task输入输出都存储在文件系统中,改框架负责调度任务. Hadoop分布式文件系统Hadoop可以直接与任何安装的分布式文件系统一起工作,Hadoop使用的文件系统是HDFS.HDFS基于谷歌文件系统(GFS),并提供一个分布式文件系统,并提供了一个类似任何其他文件系统的shell,用命令与文件交互. Hadoop工作流程第一阶段:用户/应用程序可以通过指定以下项目来向Hadoop（hadoop作业客户端）提交作业以获取所需的进程：分布式文件系统中输入和输出文件的位置。java类以jar文件的形式包含map和reduce函数的实现。通过设置作业的不同参数来配置作业。第二阶段:Hadoop作业客户端然后将作业（jar /可执行文件等）和配置提交给JobTracker，JobTracker然后承担将软件/配置分发给从属的责任，Hadoop作业客户端然后将作业（jar /可执行文件等）和配置提交给JobTracker，JobTracker然后承担将软件/配置分发给从属的责任。第三阶段：不同节点上的TaskTracker根据MapReduce实现执行任务，reduce函数的输出存储在文件系统上的输出文件中。 Hadoop优势快速编写和测试分布系统,高效;不依赖硬件提供容错和高可用性;服务器可以动态添加或从集群中删除，Hadoop继续运行而不中断。Hadoop是开源产品,基于Java,在所有平台上都兼容. HDFS文件读写过程文件读取剖析(1)客户端通过调用FileSystem对象的open()来读取要打开的文件(2)DistributedFileSystem通过RPC来调用namenode，以确定文件的开头部分的块位置对于每一块，namenode返回具有该块副本的datanode地址。此外，这些datanode根据他们与client的距离来排序（根据网络集群的拓扑）。(3)接着client对这个输入流调用read()。存储着文件开头部分的块的数据节点的地址DFSInputStream随即与这些块最近的datanode相连接。(4)通过在数据流中反复调用read()，数据会从datanode返回client。(5)到达块的末端时，DFSInputStream会关闭与datanode间的联系，然后为下一个块找到最佳的datanode。client端只需要读取一个连续的流，这些对于client来说都是透明的。 文件写入剖析⑴客户端通过在DistributedFileSystem中调用create()来创建文件。⑵DistributedFileSystem 使用RPC去调用namenode，在文件系统的命名空间创一个新的文件，没有块与之相联系。namenode执行各种不同的检查以确保这个文件不会已经存在，并且在client有可以创建文件的适当的许可。分布式文件系统返回一个文件系统数据输出流，让client开始写入数据。就像读取事件一样，文件系统数据输出流控制一个DFSOutputStream，负责处理datanode和namenode之间的通信。⑶在client写入数据时，DFSOutputStream将它分成一个个的包，写入内部的队列，成为数据队列。数据队列随数据流流动，数据流的责任是根据适合的datanode的列表要求这些节点为副本分配新的块。这个数据节点的列表形成一个管线————假设副本数是3，所以有3个节点在管线中。⑷数据流将包分流给管线中第一个的datanode，这个节点会存储包并且发送给管线中的第二个datanode。同样地，第二个datanode存储包并且传给管线中的第三个数据节点。⑸DFSOutputStream也有一个内部的包队列来等待datanode收到确认，成为确认队列。一个包只有在被管线中所有的节点确认后才会被移除出确认队列。⑹client完成数据的写入后，就会在流中调用close()。⑺在向namenode节点发送完消息之前，此方法会将余下的所有包放入datanode管线并等待确认。namenode节点已经知道文件由哪些块组成（通过Data streamer 询问块分配），所以它只需在返回成功前等待块进行最小量的复制。 API操作HDFS使用HDFS的JAVA API操作HDFS的文件系统，首先要获取用于操作文件系统的实例，而文件系统的又是与当前的系统的环境变量息息相关。对于操作HDFS来说，环境配置主要是core-site.xml中的相关配置。 获取文件系统访问实例①Configuration conf = new Configuration(); //获取当前的默认环境配置 ②FileSystem fs = FileSystem.get(conf); //根据当前环境配置，获取文件系统访问实例 Configuration还用提供了用于增加/修改当前环境配置的相关方法，如addResource(Path file)可以增加xml格式的配置,set(String name,String value)以键值对的形式新增/修改配置项。 获取文件系统访问实例方法有： ①public static FileSystem get(Configuration conf) throws IOException; ②public static FileSystem get(URI uri,Configuration conf) throws IOException; 第一个方法是使用默认的URI地址(core-site.xml中配置)获取当前环境变量来加载文件系统，第二个方法则传入指定的URI路径来获取实例。 向HDFS中写入数据①public FSDataOutputStream create(Path f) throws IOException; ②public FSDataOutputStream append(Path f) throws IOException; ③public void write(byte b[]) throws IOException; ④public final void writeBytes(String s) throws IOException ⑤public final void writeUTF(String str) throws IOException 首先要根据当前的环境，获取写出数据了对象，create方法根据路径创建数据流对象，如果path目录的文件已经存在，则会覆盖原文件的内容。append方法则在原路径的文件上追加写入。都返回了FSDataOutputStream对象，其继承至DataOutputStream，提供了标准I/O的操作。FSDataOutputStream提供了很多写出数据流的方法如重载的write,writeBytes,writeUTF等。flush提供了一种将缓冲区的数据强制刷新到文件系统的方法。此外，write()提供了一种带有回调方法的参数，回去在每次写出缓存时，提供进度。 读取HDFS文件系统的数据①public FSDataInputStream open(Path f) throws IOException; ②public final int read(byte b[], int off, int len) throws IOException; ③public class FSDataInputStream extends DataInputStream implements Seekable, PositionedReadable, ByteBufferReadable, HasFileDescriptor, CanSetDropBehind, CanSetReadahead, HasEnhancedByteBufferAccess, CanUnbuffer ; open()方法根据传进来的path路径，获取环境变量，并设置读取的缓冲区大小（默认为4096），然后返回FSDataInputStream实例，FSDataInputStream继承至DataInputStream，并实现了Seekable等接口。DataInputStream继承至标准I/O类，Seekable接口实现对数据的重定位，PositionedReadable接口实现从指定偏移量处读取文件。 read()方法从指定off位置读取len长度的字节存入byte数组。如果到达文件尾则返回-1，否则返回读取的实际长度。 文件/目录操作①public boolean mkdirs(Path f) throws IOException; 提供递归的创建path目录功能，mkdirs还有带权限的重载版本 ②public abstract boolean delete(Path paramPath, boolean paramBoolean) throws IOException; 如果paramBoolean为false，则不能递归的删除子目录，如果此时目录非空，将抛出异常Directory is not empty ③public abstract FileStatus[] listStatus(Path paramPath) throws FileNotFoundException, IOException; ④private void listStatus(ArrayList results, Path f, PathFilter filter) throws FileNotFoundException, IOException; listStatus方法可以列出指定目录下的文件或者文件夹（不能递归列出），具有PathFilter过滤的重载版本 FileStatus对象描述了文件的各种属性，诸如文件是否是文件夹，文件的权限，所有者等，isDirectory(),getLen(),getPath()… ⑤copyFromLocalFile(src, dst); //从本地拷贝文件到HDFS ⑥copyToLocalFile(src, dst); //从HDFS直接拷贝文件到本地","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/大数据/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://yoursite.com/tags/hadoop/"},{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/tags/大数据/"},{"name":"MapReduce","slug":"MapReduce","permalink":"http://yoursite.com/tags/MapReduce/"}]},{"title":"集合","slug":"集合","date":"2019-09-04T07:19:52.548Z","updated":"2019-05-23T06:35:40.747Z","comments":true,"path":"2019/09/04/集合/","link":"","permalink":"http://yoursite.com/2019/09/04/集合/","excerpt":"集合1.collection接口是set、list和queue接口的父接口 基本操作：add（）、addAll（）、clear（）、contains（）、iterator（）、remove（）、retainAll（）、size（）、toArray（）。","text":"集合1.collection接口是set、list和queue接口的父接口 基本操作：add（）、addAll（）、clear（）、contains（）、iterator（）、remove（）、retainAll（）、size（）、toArray（）。 2.Collection的遍历可以使用Iterator接口或者foreach循环实现 3.Set子接口 3.1 HashSet 特点:(1)无序且不可重复,加入的元素注意hashCode()方法的实现 (2)HashSet不是同步的,多线程访问同一步HashSet对象,需要手工同步 (3)集合元素值可以为null 3.2 SortedSet接口及TreeSet实现类 TreeSet是SortedSet接口的实现类,因需要排序,所以性能肯定差于HashSet. 4.List子接口 4.1 ArrayList和Vector实现类 (1)都是基于数组实现的List类 (2)ArrayList是线程不安全的,而Vector是线程安全的.但Vector的性能会 比ArrayList低. (3)Vector提供一个子类Stack,方便模拟”栈”这种数据结构. (4)ArrayList随机访问速度一般,插入 删除 迭代速度一般.有序且可重复的 4.2 LinkedList类 链表实现的,随机访问速度不太好,插入 删除 迭代速度非常快. 5.Map集合 采用key-value键值对的方式进行存储. key是唯一的,value可以重复. key是无序唯一的,value是无序不唯一的. map接口有两个集合HashMap和TreeMap,hashMap采用哈希表的存储结构,数据是无序且唯一的(实现唯一的方式是重写Hashcode和equals方法). 三种遍历方式 (1)map.keySet()将map中的key以set集合的形式返回,遍历所有key (2)Set&lt;Entry&lt;K,V&gt;&gt; entrySet()每组键值对是一个Entry实例 (3)Collection values() 存入到集合中返回,新循环遍历 总结:Collection 是对象集合， Collection 有两个子接口 List 和 Set,List 可以通过下标 (1,2..) 来取得值，值可以重复,而 Set 只能通过游标来取值，并且值是不能重复的ArrayList ， Vector ， LinkedList 是 List 的实现类ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的LinkedList 是线程不安全的，底层是由链表实现的Map 是键值对集合HashTable 和 HashMap 是 Map 的实现类HashTable 是线程安全的，不能存储 null 值HashMap 不是线程安全的，可以存储 null 值 ArrayList集合时有序且可重复的,HashSet集合是无序且不可重复的","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/tags/基础知识/"},{"name":"比较","slug":"比较","permalink":"http://yoursite.com/tags/比较/"},{"name":"集合相关知识","slug":"集合相关知识","permalink":"http://yoursite.com/tags/集合相关知识/"}]},{"title":"Vue.js框架","slug":"Vue","date":"2019-09-04T07:19:52.545Z","updated":"2019-05-20T06:26:12.887Z","comments":true,"path":"2019/09/04/Vue/","link":"","permalink":"http://yoursite.com/2019/09/04/Vue/","excerpt":"Vue.js框架Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。Vue 只关注视图层， 采用自底向上增量开发的设计。Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。","text":"Vue.js框架Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。Vue 只关注视图层， 采用自底向上增量开发的设计。Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 Vue.js 安装1、独立版本我们可以在 Vue.js 的官网上直接下载 vue.min.js 并用 script 标签引入。 下载vue.js 2、使用 CDN 方法以下推荐国外比较稳定的两个 CDN，国内还没发现哪一家比较好，目前还是建议下载到本地。Staticfile CDN(国内): https://cdn.staticfile.org/vue/2.2.2/vue.min.jsunpkg：https://unpkg.com/vue/dist/vue.js, 会保持和 npm 发布的最新的版本一致。cdnjs: https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js 3、NPM 方法由于 npm 安装速度慢，本教程使用了淘宝的镜像及其命令 cnpm，安装使用介绍参照：使用淘宝 NPM 镜像。npm 版本需要大于 3.0，如果低于此版本需要升级它。 查看版本$ npm -v 2.3.0 升级 npmcnpm install npm -g 升级或安装 cnpmnpm install cnpm -g 在用 Vue.js 构建大型应用时推荐使用 NPM 安装 最新稳定版$ cnpm install vue 命令行工具Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。 全局安装 vue-cli$ cnpm install --global vue-cli 创建一个基于 webpack 模板的新项目$ vue init webpack my-project 这里需要进行一些配置，默认回车即可 进入项目，安装并运行： $ cd my-project $ cnpm install $ cnpm run dev DONE Compiled successfully in 4388ms > Listening at http://localhost:8080 目录结构 目录/文件 说明 build 项目构建(webpack)相关代码 config 配置目录，包括端口号等。我们初学可以使用默认的 node_modules npm 加载的项目依赖模块 src 这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：assets: 放置一些图片，如logo等; components: 目录里面放了一个组件文件，可以不用; App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录; main.js: 项目的核心文件。 test 静态资源目录，如图片、字体等。 .xxxx文件 这些是一些配置文件，包括语法配置，git配置等。 index.html 首页入口文件，你可以添加一些 meta 信息或统计代码啥的。 package.json 项目配置文件。 README.md 项目的说明文档，markdown 格式 Vue.js起步每个 Vue 应用都需要通过实例化 Vue 来实现。语法格式如下： var vm = new Vue({ // 选项 }) 在 Vue 构造器中有一个el 参数，它是 DOM 元素中的 id。在上面实例中 id 为 vue_det，在 div 元素中： &lt;div id = \"vue_det\">&lt;/div> 这意味着我们接下来的改动全部在以上指定的 div 内，div 外部不受影响。 接下来我们看看如何定义数据对象。data 用于定义属性，实例中有三个属性分别为：site、url、alexa。methods 用于定义的函数，可以通过 return 来返回函数值。 双大括号用于输出对象属性和函数返回值。如: 当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，html 视图将也会产生相应的变化。 除了数据属性，Vue 实例还提供了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来。例如： Vue语法Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到DOM 操作上. 插值文本数据绑定最常见的形式就是使用(双大括号)的文本插值： 文本插值 Html使用 v-html 指令用于输出 html 代码：v-html 指令 属性HTML 属性中的值应使用 v-bind 指令。以下实例判断 class1 的值，如果为 true 使用 class1 类的样式，否则不使用该类： 表达式Vue.js 都提供了完全的 JavaScript 表达式支持。 指令指令是带有 v- 前缀的特殊属性。指令用于在表达式的值改变时，将某些行为应用到 DOM 上。如下例子：这里， v-if 指令将根据表达式 seen 的值(true 或 false )来决定是否插入 p 元素。 参数参数在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性：在这里 href 是参数，告知 v-bind 指令将该元素的 href 属性与表达式 url 的值绑定。另一个例子是 v-on 指令，它用于监听 DOM 事件： &lt;a v-on:click=\"doSomething\"> 在这里参数是监听的事件名。 修饰符修饰符是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： &lt;form v-on:submit.prevent=\"onSubmit\">&lt;/form> 用户输入在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定： v-model 指令用来在 input、select、text、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。按钮的事件我们可以使用 v-on 监听事件，并对用户的输入进行响应。以下实例在用户点击按钮后对字符串进行反转操作： 过滤器Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。由”管道符”指示, 格式如下： &lt;!-- 在两个大括号中 --> {{ message | capitalize }} 在 v-bind 指令中 &lt;div v-bind:id=\"rawId | formatId\">&lt;/div> 过滤器函数接受表达式的值作为第一个参数。以下实例对输入的字符串第一个字母转为大写： 过滤器可以串联： {{ message | filterA | filterB }} 过滤器是 JavaScript 函数，因此可以接受参数： {{ message | filterA('arg1', arg2) }} 这里，message 是第一个参数，字符串 ‘arg1’ 将传给过滤器作为第二个参数， arg2 表达式的值将被求值然后传给过滤器作为第三个参数。 缩写v-bind 缩写Vue.js 为两个最为常用的指令提供了特别的缩写： &lt;!-- 完整语法 --> &lt;a v-bind:href=\"url\">&lt;/a> &lt;!-- 缩写 --> &lt;a :href=\"url\">&lt;/a> v-on 缩写 &lt;!-- 完整语法 --> &lt;a v-on:click=\"doSomething\">&lt;/a> &lt;!-- 缩写 --> &lt;a @click=\"doSomething\">&lt;/a> Vue.js 条件与循环v-if条件判断使用 v-if 指令：在元素 和 template 中使用 v-if 指令： 这里， v-if 指令将根据表达式 seen 的值(true 或 false )来决定是否插入 p 元素。在字符串模板中，如 Handlebars ，我们得像这样写一个条件块： v-else可以用 v-else 指令给 v-if 添加一个 “else” 块：随机生成一个数字，判断是否大于0.5，然后输出对应信息： v-else-ifv-else-if 在 2.1.0 新增，顾名思义，用作 v-if 的 else-if 块。可以链式的多次使用：v-else 、v-else-if 必须跟在 v-if 或者 v-else-if之后。 v-show我们也可以使用 v-show 指令来根据条件展示元素 v-show 指令 &lt;h1 v-show=\"ok\">Hello!&lt;/h1> 循环语句循环使用 v-for 指令。v-for 指令需要以 site in sites 形式的特殊语法， sites 是源数据数组并且site 是数组元素迭代的别名。 v-for 可以绑定数据到数组来渲染一个列表： 模板中使用 v-for： 你也可以提供第二个的参数为键名： 第三个参数为索引： v-for 迭代整数v-for 也可以循环整数 Vue.js 计算属性计算属性关键词: computed反转字符串的例子： computed vs methods我们可以使用 methods 来替代 computed，效果上两个都是一样的，但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。 使用 computed 性能会更好，但是如果你不希望缓存，你可以使用 methods 属性 computed settercomputed 属性默认只有 getter ，不过在需要时你也可以提供一个 setter ： 从实例运行结果看在运行 vm.site = ‘前端框架 http://www.tangdev.top&#39;; 时，setter 会被调用，vm.name 和 vm.url 也会被对应更新 Vue.js 监听属性Vue.js 监听属性 watch，我们可以通过 watch 来响应数据的变化 以下实例通过使用 watch 实现计数器： 实现效果: 购物车案例: 实现效果: Vue.js 样式绑定Vue.js classclass与style是 TML元素的属性，用于设置元素的样式，我们可以用v-bind来设置样式属性。vue.jsv-bind在处理class和style时,专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。 class属性绑定v-bind:class设置一个对象，从而动态的切换 class: 可以在对象中传入更多属性用来动态切换多个 class text-danger 类背景颜色覆盖了 active 类的背景色： &lt;div class=\"static\" v-bind:class=\"{ active: isActive, 'text-danger': hasError }\"> &lt;/div> 也可以直接绑定数据里的一个对象： 也可以在这里绑定返回对象的计算属性。这是一个常用且强大的模式： 数组语法把一个数组传给 v-bind:class ，实例如下： 使用三元表达式来切换列表中的 class ： Vue.js style(内联样式)在 v-bind:style 直接设置样式： v-bind:style 可以使用数组将多个样式对象应用到一个元素上： 注意：当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform ，Vue.js 会自动侦测并添加相应的前缀。 Vue.js 事件处理器事件监听可以使用 v-on 指令： v-on 可以接收一个定义的方法来调用 直接绑定到一个方法，也可以用内联 JavaScript 语句： 事件修饰符Vue.js 为 v-on 提供了事件修饰符来处理 DOM 事件细节，如：event.preventDefault() 或 event.stopPropagation()。Vue.js通过由点(.)表示的指令后缀来调用修饰符。 .stop .prevent .capture .self .once &lt;!-- 阻止单击事件冒泡 --> &lt;a v-on:click.stop=\"doThis\">&lt;/a> &lt;!-- 提交事件不再重载页面 --> &lt;form v-on:submit.prevent=\"onSubmit\">&lt;/form> &lt;!-- 修饰符可以串联 --> &lt;a v-on:click.stop.prevent=\"doThat\">&lt;/a> &lt;!-- 只有修饰符 --> &lt;form v-on:submit.prevent>&lt;/form> &lt;!-- 添加事件侦听器时使用事件捕获模式 --> &lt;div v-on:click.capture=\"doThis\">...&lt;/div> &lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --> &lt;div v-on:click.self=\"doThat\">...&lt;/div> &lt;!-- click 事件只能点击一次，2.1.4版本新增 --> &lt;a v-on:click.once=\"doThis\">&lt;/a> 按键修饰符Vue 允许为 v-on 在监听键盘事件时添加按键修饰符： &lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --> &lt;input v-on:keyup.13=\"submit\"> 记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名： &lt;!-- 同上 --> &lt;input v-on:keyup.enter=\"submit\"> &lt;!-- 缩写语法 --> &lt;input @keyup.enter=\"submit\"> .enter .tab .delete (捕获 &quot;删除&quot; 和 &quot;退格&quot; 键) .esc .space .up .down .left .right .ctrl .alt .shift .meta 实例: &lt;p>&lt;!-- Alt + C --> &lt;input @keyup.alt.67=\"clear\"> &lt;!-- Ctrl + Click --> &lt;div @click.ctrl=\"doSomething\">Do something&lt;/div> Vue.js 表单用 v-model 指令在表单控件元素上创建双向数据绑定 复选框复选框如果是一个为逻辑值，如果是多个则绑定到同一个数组：结果: 单选按钮单选按钮的双向数据绑定：结果: select 列表下拉列表的双向数据绑定：结果: 修饰符.lazy在默认情况下， v-model 在 input 事件中同步输入框的值与数据，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步： &lt;!-- 在 \"change\" 而不是 \"input\" 事件中更新 --> &lt;input v-model.lazy=\"msg\" > .number如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值： &lt;input v-model.number=\"age\" type=\"number\"> 这通常很有用，因为在 type=”number” 时 HTML 中输入的值也总是会返回字符串类型。 .trim如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入： &lt;input v-model.trim=\"msg\"> Vue.js 组件组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树：注册一个全局组件语法格式如下： Vue.component(tagName, options) tagName 为组件名，options 为配置选项。注册后，我们可以使用以下方式来调用组件： &lt;tagName>&lt;/tagName> Vue.js 自定义指令除了默认设置的核心指令( v-model 和 v-show ), Vue 也允许注册自定义指令。下面我们注册一个全局指令 v-focus, 该指令的功能是在页面加载时，元素获得焦点： &lt;body> &lt;div id=\"app\"> &lt;p>页面载入时，input 元素自动获取焦点：&lt;/p> &lt;input v-focus> &lt;/div> &lt;script> // 注册一个全局自定义指令 v-focus Vue.directive('focus', { // 当绑定元素插入到 DOM 中。 inserted: function (el) { // 聚焦元素 el.focus() } }) // 创建根实例 new Vue({ el: '#app' }) &lt;/script> &lt;/body> 钩子钩子函数指令定义函数提供了几个钩子函数（可选）： bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行 一次的初始化动作。 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值， 可以忽略不必要的模板更新（详细的钩子函数参数见下）。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。 unbind: 只调用一次， 指令与元素解绑时调用。 钩子函数参数钩子函数的参数有： el: 指令所绑定的元素，可以用来直接操作 DOM 。 binding: 一个对象，包含以下属性： name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=&quot;1 + 1&quot;, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。 无论值是否改变都可用。 expression: 绑定值的表达式或变量名。 例如 v-my-directive=&quot;1 + 1&quot; ， expression 的值是 &quot;1 + 1&quot;。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 &quot;foo&quot;。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点。 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 Vue.js 过渡 &amp; 动画过渡Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。Vue 提供了内置的过渡封装组件，该组件用于包裹要实现过渡效果的组件。 &lt;transition name = \"nameoftransition\"> &lt;div>&lt;/div> &lt;/transition> 过渡其实就是一个淡入淡出的效果。Vue在元素显示与隐藏的过渡中，提供了 6 个 class 来切换： v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之 前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时 立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 ####自定义过渡的类名通过以下特性来自定义过渡类名： enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) 自定义过渡的类名优先级高于普通的类名，这样就能很好的与第三方（如：animate.css）的动画库结合使用。 同时使用过渡和动画Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。 但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。 显性的过渡持续时间在很多情况下，Vue 可以自动得出过渡效果的完成时机。默认情况下，Vue 会等待其在过渡效果的根元素的第一个 transitionend 或 animationend 事件。然而也可以不这样设定——比如，我们可以拥有一个精心编排的一系列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。在这种情况下你可以用 组件上的 duration 属性定制一个显性的过渡持续时间 (以毫秒计) JavaScript 钩子 &lt;transition v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:after-enter=\"afterEnter\" v-on:enter-cancelled=\"enterCancelled\" v-on:before-leave=\"beforeLeave\" v-on:leave=\"leave\" v-on:after-leave=\"afterLeave\" v-on:leave-cancelled=\"leaveCancelled\" > &lt;!-- ... --> &lt;/transition> // ... methods: { // -------- // 进入中 // -------- beforeEnter: function (el) { // ... }, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 enter: function (el, done) { // ... done() }, afterEnter: function (el) { // ... }, enterCancelled: function (el) { // ... }, // -------- // 离开时 // -------- beforeLeave: function (el) { // ... }, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function (el, done) { // ... done() }, afterLeave: function (el) { // ... }, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) { // ... } } 初始渲染的过渡可以通过 appear 特性设置节点在初始渲染的过渡 &lt;transition appear> &lt;!-- ... --> &lt;/transition> 多个元素的过渡设置多个元素的过渡，一般列表与描述：需要注意的是当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。 &lt;transition> &lt;table v-if=\"items.length > 0\"> &lt;!-- ... --> &lt;/table> &lt;p v-else>抱歉，没有找到您查找的内容。&lt;/p> &lt;/transition> Vue.js Ajax(vue-resource)Vue 要实现异步加载需要使用到 vue-resource 库。 &lt;script src=\"https://cdn.staticfile.org/vue-resource/1.5.1/vue-resource.min.js\">&lt;/script> Get 请求点击:结果: 如果需要传递数据，可以使用 this.$http.get(‘get.php’,jsonData) 格式，第二个参数jsonData 就是传到后端的数据。 post 请求post 发送数据到后端，需要第三个参数 {emulateJSON:true}。emulateJSON 的作用： 如果Web服务器无法处理编码为 application/json 的请求，可以启用 emulateJSON 选项。 语法 &amp; API可以使用全局对象方式 Vue.http 或者在一个 Vue 实例的内部使用 this.$http来发起 HTTP 请求 属性 类型 描述 url string 请求的目标URL body Object, FormData, string 作为请求体发送的数据 headers Object 作为请求头部发送的头部对象 params Object 作为URL参数的参数对象 method string HTTP方法 (例如GET，POST，…) timeout number 请求超时（单位：毫秒） (0表示永不超时) before function(request) 在请求发送之前修改请求的回调函数 progress function(event) 用于处理上传进度的回调函数 ProgressEvent credentials boolean 是否需要出示用于跨站点请求的凭据 emulateHTTP boolean 是否需要通过设置X-HTTP-Method-Override头部并且以传统POST方式发送PUT，PATCH和DELETE请求。 emulateJSON boolean 设置请求体的类型为application/x-www-form-urlencoded Vue.js 响应接口Vue 可以添加数据动态响应接口。例如以下实例，我们通过使用 $watch 属性来实现数据的监听，$watch 必须添加在 Vue 实例之外才能实现正确的响应。实例中通过点击按钮计数器会加 1。setTimeout 设置 10 秒后计算器的值加上 20 。 Vue.setVue.set 方法用于设置对象的属性，它可以解决 Vue 无法检测添加属性的限制，语法格式如下： Vue.set( target, key, value ) 参数说明： target: 可以是对象或数组 key : 可以是字符串或数字 value: 可以是任何类型 Vue.deleteVue.delete 用于删除动态添加的属性 语法格式： Vue.delete( target, key ) 参数说明： target: 可以是对象或数组 key : 可以是字符串或数字","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/tags/前端知识/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"},{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/框架/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Spring常用注解","slug":"Spring注解大全","date":"2019-09-04T07:19:52.542Z","updated":"2019-05-21T07:28:45.626Z","comments":true,"path":"2019/09/04/Spring注解大全/","link":"","permalink":"http://yoursite.com/2019/09/04/Spring注解大全/","excerpt":"Spring常用注解1 、将普通类加入容器形成Bean的注解日常主要使用到的定义Bean的注解包括(XML方式配置bean暂不讨论)： @Component、@Repository、@Service、@Controller、@Bean 其中@Component、@Repository、@Service、@Controller实质上属于同一类注解，用法相同，功能相同，区别在于标识组件的类型。当一个组件代表数据访问层(Dao)时，你可以给它加上@Repository注解，如下例：","text":"Spring常用注解1 、将普通类加入容器形成Bean的注解日常主要使用到的定义Bean的注解包括(XML方式配置bean暂不讨论)： @Component、@Repository、@Service、@Controller、@Bean 其中@Component、@Repository、@Service、@Controller实质上属于同一类注解，用法相同，功能相同，区别在于标识组件的类型。当一个组件代表数据访问层(Dao)时，你可以给它加上@Repository注解，如下例： @Repository public class TestDaoImpl implements TestDao { public void run(){ .... } } 当组件用于业务层时，使用@Service注解，如下例： @Service(value=&quot;TestService&quot;) public class TestServiceImpl implements TestService { @Autowired private TestDao testDao; public void run(){ ... } } 注: 在此处的@Service注解中额外添加了value=”TestService”的属性，为何对此一举呢？ value属性可以指定生成后Bean的名称，这个名称便成为容器中bean 的唯一标识符。 同样的，在@Component、@Repository、@Controller也均可以指定其value值，当然， 是如有必要时加。 当组件属于控制层时，则使用@Controller注解；当组件不能进行很好地归类时,那我们可以 使用@Component注解。 @Bean注解和@Configuration注解事例 /** * 配置普通java类 bean方法 */ @Configuration @Component public class SpringBeansConfig { @Bean public SnowFlakeLh snowFlake() { return new SnowFlakeLh(); } } @Configuration实际上，常与@Bean注解一起使用的。如果将一个类标注为@Configuration注解，那么也就意味着这个class将会作为创建各种bean的工厂（类似于一个新的容器）。Bean注解主要用于方法上，有点类似于工厂方法，当使用了@Bean注解，我们可以连续使用多种定义bean时用到的注解，spring注入直接托管给spring管理，类似接口，使用该方法时直接使用@Autowired注入。以上的代码实际上等价于Xml中的配置： &lt;beans&gt; &lt;bean class=&quot;com.acme.services.SnowFlakeLh&quot; id=&quot;snowFlake&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 注: 在Spring的@Component注解中使用@Bean与在Spring中的@Configuration使用是一定的差别 的。在使用@Component的类中不会强制使用CGLIB代理拦截方法和属性。而在@Configuration 类中，则会使用CGLIB代理去调用@Bean标注的方法并返回对象的引用。在@Configuration注 解中使用@Bean也可以防止同一个@Bean方法被意外调用多次时而产生细微的难以排查的错误 2 、从容器中取Bean（装配bean）时常用的注解最常用到的用于装配的注解是：@Autowired和@Resourc @Autowired注解 @Service public class UserServiceImpl implements UserService{ @Autowired private TBUserMapper userMapper; } @Autowired注解可用于为类的属性、构造器、方法进行注值。默认情况下，其依赖的对象必须存在（bean可用），如果需要改变这种默认方式，可以设置其required属性为false。另外一个比较重要的点就是，@Autowired注解默认按照类型装配，如果容器中包含多个同一类型的Bean，那么启动容器时会报找不到指定类型bean的异常，解决办法是结合@Qualified注解进行限定，指定注入的bean名称 @Resource注解默认情况下按照bean的名称进行注入，当找不到匹配项时会按照类型装配。当按照名称进行装配时，可以指定其name属性，倘若没有指定，注解标注在哪个字段上，其默认名称就是那个字段的名称。当然，@Resource注解也支持按指定类型进行装配，给它的type属性赋特定类型的值即可（注意，当指定了name属性后，只能按照名称装配） public class SpringAnotationDemo { @Resource(name = &quot;httpApiClient&quot;) private HttpApiClient httpApiClient; @Resource(type = XQSmsHttpClient.class) private SmsHttpClient smsHttpClient; } 3、spring MVC模块注解常用到的注解包括： @Controller、@RequestMapping、@RequestParam、@PathVariable @Controller将一个类加上@Controller注解后，表明该类会作为与前端作交互的控制层组件 @Controller public class CompanyController { ... } @RequestMapping这个注解用于将url映射到整个处理类或者特定的处理请求的方法 @Controller @RequestMapping(&quot;/company&quot;) public class CompanyController { @Autowired private CompanyService companyService; ... } 当标注在class上时，表明此类会接收url为”/company”请求 @RequestParam用于绑定request请求参数到指定的方法 @Controller @RequestMapping(&quot;/company&quot;) public class CompanyController { @Autowired private CompanyService companyService; @RequestMapping(&quot;/companyList&quot;) public String listCompanies(Map&lt;string, object=&quot;&quot;&gt; map, @RequestParam(value = &quot;data&quot;, required = false) String data, @RequestParam(value = &quot;phone_num&quot;, required = true) String phoneNum) { map.put(&quot;data&quot;, data); map.put(&quot;phoneNum&quot;, phoneNum); return &quot;companyList&quot;; } ... } 上例中，@RequestParam请求参数指定了传入参数的具体字段名（value指定的），以及是否必须传的字段（默认情况下，required=true）。data,phoneNum为形参，即请求参数的使用名，可以更改 @PathVariable该注解用于方法修饰方法参数，会将修饰的方法参数变为可供使用的uri变量（可用于动态绑定） @Controller @RequestMapping(&quot;/company&quot;) public class CompanyController { @Autowired private CompanyService companyService; @RequestMapping(&quot;{companyName}&quot;) public String getCompany(Map&lt;string, object=&quot;&quot;&gt; map, @PathVariable String companyName) { Company company = companyService.findByName(companyName); map.put(&quot;company&quot;, company); return &quot;company&quot;; } ... } 当我们请求 “/compony/account”时，componyName会动态地绑定为”account” 4、事务模块注解@Transactional在处理dao层或service层的事务操作时，譬如删除失败时的回滚操作，可用到@Transactional注解如: @Service public class CompanyServiceImpl implements CompanyService { @Autowired private CompanyDAO companyDAO; @Transactional(propagation = Propagation.REQUIRED, readOnly = false, rollbackFor = Exception.class) public int deleteByName(String name) { int result = companyDAO.deleteByName(name); return company; } ... } 上例表明，执行deleteByName方法时，启用了事务处理，事务的各属性含义如下： propagation事务的传播行为，spring在TransactionDefinition接口中规定了7种类型的事务传播行为，它们规定了事务方法和事务方法发生嵌套调用时如何进行传播： 事务传播行为类型 描述 PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。 PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类 似的操作 注：第一种是最常用的，默认的 readOnly事务的读写属性，取true或者false，true为只读、默认为false rollbackFor回滚策略，当遇到指定异常时回滚。譬如上例遇到异常就回滚 timeout （补充的）设置超时时间，单位为秒 isolation设置事务隔离级别，枚举类型，一共五种 类型 描述 DEFAULT 采用数据库默认隔离级别 READ_UNCOMMITTED 读未提交的数据（会出现脏读取） READ_COMMITTED 读已提交的数据（会出现幻读，即前后两次读的不一样） REPEATABLE_READ 可重复读，会出现幻读 SERIALIZABLE 串行化（对资源消耗较大，一般不使用） 5、Spring AOP模块注解spring aop模块的注解主要有@Aspect、@Pointcut、@Before、@Around、@After、@AfterReturning、@AfterThrowing @Aspect标明该类为切面类，并启用AspectJ注解，注：在使用时要同@Component一起使用，否则不会被扫描到加入容器 @Pointcut定义切入点，关于切入点表达式书写方式，请移步官方文档：spring AOP文档 @Around定义环绕通知，在目标方法执行前后嵌入相关业务逻辑 @Before定义前置通知，在目标方法执行前执行 @After定义后置通知，在目标方法执行后执行，不论是目标方法执行正常后退出，还是抛出异常后退出，均会被执行 @AfterReturning目标方法执行正常退出后执行 @AfterThrowing目标方法执行抛出异常后执行 总结以上是Spring常用注解的全部内容,记录下来方便以后查看学习.","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"http://yoursite.com/categories/Java/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"注解","slug":"注解","permalink":"http://yoursite.com/tags/注解/"}]},{"title":"spring boot集成Lombok","slug":"springboot集成lombok","date":"2019-09-04T07:19:52.539Z","updated":"2019-05-27T08:52:24.277Z","comments":true,"path":"2019/09/04/springboot集成lombok/","link":"","permalink":"http://yoursite.com/2019/09/04/springboot集成lombok/","excerpt":"spring boot集成Lombok1.先去http://start.spring.io/在线生成一个spring boot项目脚手架，导入eclipse/idea。2.在pom.xml里添加Lombok依赖： &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.14&lt;/version&gt; &lt;/dependency&gt;","text":"spring boot集成Lombok1.先去http://start.spring.io/在线生成一个spring boot项目脚手架，导入eclipse/idea。2.在pom.xml里添加Lombok依赖： &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.14&lt;/version&gt; &lt;/dependency&gt; Lombok常用注解@NonNull这个注解可以用在成员方法或者构造方法的参数前面，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，举个例子： 编译前的代码： //成员方法参数加上@NonNull注解 public String getName(@NonNull Person p) { return p.getName(); } 编译后的代码： public String getName(@NonNull Person p) { if (p == null) { throw new NullPointerException(&quot;person&quot;); } return p.getName(); } @Cleanup这个注解用在变量前面，可以保证此变量代表的资源会被自动关闭，默认是调用资源的close()方法，如果该资源有其它关闭方法，可使用@Cleanup(“methodName”)来指定要调用的方法，就用输入输出流来举个例子： 编译前的代码： public static void main(String[] args) throws IOException { @Cleanup InputStream in = new FileInputStream(args[0]); @Cleanup OutputStream out = new FileOutputStream(args[1]); byte[] b = new byte[1024]; while (true) { int r = in.read(b); if (r == -1) break; out.write(b, 0, r); } } 编译后的代码： public static void main(String[] args) throws IOException { InputStream in = new FileInputStream(args[0]); try { OutputStream out = new FileOutputStream(args[1]); try { byte[] b = new byte[10000]; while (true) { int r = in.read(b); if (r == -1) break; out.write(b, 0, r); } } finally { if (out != null) { out.close(); } } } finally { if (in != null) { in.close(); } } } @Getter/@Setter这一对注解用在成员变量前面，相当于为成员变量生成对应的get和set方法，同时还可以为生成的方法指定访问修饰符，当然，默认为public，直接来看下面的简单的例子： 如: public class Programmer { @Getter @Setter private String name; @Setter(AccessLevel.PROTECTED) private int age; @Getter(AccessLevel.PUBLIC) private String language; } 这两个注解还可以直接用在类上，可以为此类里的所有非静态成员变量生成对应的get和set方法。 @Getter(lazy=true)如果Bean的一个字段的初始化是代价比较高的操作，比如加载大量的数据；同时这个字段并不是必定使用的。那么使用懒加载机制，可以保证节省资源。 懒加载机制，是对象初始化时，该字段并不会真正的初始化，而是第一次访问该字段时才进行初始化字段的操作。 @ToString/@EqualsAndHashCode这两个注解也比较好理解，就是生成toString，equals和hashcode方法，同时后者还会生成一个canEqual方法，用于判断某个对象是否是当前类的实例，生成方法时只会使用类中的非静态和非transient成员变量，这些都比较好理解，就不举例子了。 当然，这两个注解也可以添加限制条件，例如用@ToString(exclude={“param1”,”param2”})来排除param1和param2两个成员变量，或者用@ToString(of={“param1”,”param2”})来指定使用param1和param2两个成员变量，@EqualsAndHashCode注解也有同样的用法。 @NoArgsConstructor/@RequiredArgsConstructor /@AllArgsConstructor这三个注解都是用在类上的，第一个和第三个都很好理解，就是为该类产生无参的构造方法和包含所有参数的构造方法，第二个注解则使用类中所有带有@NonNull注解的或者带有final修饰的成员变量生成对应的构造方法。当然，和前面几个注解一样，成员变量都是非静态的，另外，如果类中含有final修饰的成员变量，是无法使用@NoArgsConstructor注解的。 三个注解都可以指定生成的构造方法的访问权限，同时，第二个注解还可以用@RequiredArgsConstructor(staticName=”methodName”)的形式生成一个指定名称的静态方法，返回一个调用相应的构造方法产生的对象 @Data/@Value@Data注解综合了@Getter/@Setter，@ToString，@EqualsAndHashCode和@RequiredArgsConstructor注解，其中@RequiredArgsConstructor使用了类中的带有@NonNull注解的或者final修饰的成员变量，它可以使用@Data(staticConstructor=”methodName”)来生成一个静态方法，返回一个调用相应的构造方法产生的对象。 @Value注解和@Data类似，区别在于它会把所有成员变量默认定义为private final修饰，并且不会生成set方法。 @SneakyThrows这个注解用在方法上，可以将方法中的代码用try-catch语句包裹起来，捕获异常并在catch中用Lombok.sneakyThrow(e)把异常抛出，可以使用@SneakyThrows(Exception.class)的形式指定抛出哪种异常 @Synchronized这个注解用在类方法或者实例方法上，效果和synchronized关键字相同，区别在于锁对象不同，对于类方法和实例方法，synchronized关键字的锁对象分别是类的class对象和this对象，而@Synchronized的锁对象分别是私有静态final对象LOCK和私有final对象lock，当然，也可以自己指定锁对象 @Log这个注解用在类上，可以省去从日志工厂生成日志对象这一步，直接进行日志记录，具体注解根据日志工具的不同而不同，同时，可以在注解中使用topic来指定生成log对象时的类名。不同的日志注解总结如下(上面是注解，下面是编译后的代码)： @CommonsLog ==&gt; private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class); @JBossLog ==&gt; private static final org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class); @Log ==&gt; private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName()); @Log4j ==&gt; private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class); @Log4j2 ==&gt; private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class); @Slf4j ==&gt; private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class); @XSlf4j ==&gt; private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"Lombok","slug":"Lombok","permalink":"http://yoursite.com/tags/Lombok/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"Spring Boot(一)","slug":"spring boot(一)","date":"2019-09-04T07:19:52.537Z","updated":"2019-05-27T02:55:05.584Z","comments":true,"path":"2019/09/04/spring boot(一)/","link":"","permalink":"http://yoursite.com/2019/09/04/spring boot(一)/","excerpt":"Spring Boot(一)什么是 Spring BootSpring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。就是 Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。","text":"Spring Boot(一)什么是 Spring BootSpring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。就是 Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/categories/Spring-Boot/"},{"name":"Java","slug":"Spring-Boot/Java","permalink":"http://yoursite.com/categories/Spring-Boot/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"Java框架","slug":"Java框架","permalink":"http://yoursite.com/tags/Java框架/"}]},{"title":"Spring定时任务 @Scheduled注解","slug":"Scheduled注解","date":"2019-09-04T07:19:52.533Z","updated":"2019-05-21T03:40:19.187Z","comments":true,"path":"2019/09/04/Scheduled注解/","link":"","permalink":"http://yoursite.com/2019/09/04/Scheduled注解/","excerpt":"定时任务@Scheduled注解1.配置文件使用spring @Scheduled注解执行定时任务添加配置文件: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd&quot; default-autowire=&quot;byName&quot; default-lazy-init=&quot;false&quot;&gt; &lt;!-- 定时任务相关配置 --&gt; &lt;task:executor id=&quot;executor&quot; pool-size=&quot;10&quot; queue-capacity=&quot;128&quot;/&gt; &lt;task:scheduler id=&quot;scheduler&quot; pool-size=&quot;10&quot;/&gt; &lt;task:annotation-driven executor=&quot;executor&quot; scheduler=&quot;scheduler&quot; proxy-target-class=&quot;true&quot;/&gt; &lt;/beans&gt;","text":"定时任务@Scheduled注解1.配置文件使用spring @Scheduled注解执行定时任务添加配置文件: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd&quot; default-autowire=&quot;byName&quot; default-lazy-init=&quot;false&quot;&gt; &lt;!-- 定时任务相关配置 --&gt; &lt;task:executor id=&quot;executor&quot; pool-size=&quot;10&quot; queue-capacity=&quot;128&quot;/&gt; &lt;task:scheduler id=&quot;scheduler&quot; pool-size=&quot;10&quot;/&gt; &lt;task:annotation-driven executor=&quot;executor&quot; scheduler=&quot;scheduler&quot; proxy-target-class=&quot;true&quot;/&gt; &lt;/beans&gt; spring boot等框架集成了schedule,添加maven依赖包即可 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 启动类，添加启动注解在springboot入口或者配置类中增加@EnableScheduling注解即可启用定时任务。 @EnableScheduling @SpringBootApplication public class ScheduleApplication { public static void main(String[] args) { SpringApplication.run(ScheduleApplication.class, args); } } 2.调用在Java代码中使用 @Component public class testScheduled { @Scheduled(cron = &quot;0/5 * * * * ?&quot;)//每5秒执行一次 public void run() { } } 3.关于cron参数cron参数生成器 一个cron表达式有至少6个或7个(一般是6个)有空格分隔的时间元素。 按顺序依次为 秒（0~59） 分钟（0~59） 小时（0~23） 天（月）（0~31，但是你需要考虑你月的天数） 月（0~11） 天（星期）（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT） 年份（1970－2099）——@Scheduled是不支持的，spring quartz支持 字段 允许值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日期 1-31 , - * ? / L W C 月份 1-12 或者 JAN-DEC , - * / 星期 1-7 或者 SUN-SAT , - * ? / L C # 年 留空, 1970-2099 , - * / 解析:如: 0 0/1 * ? 每分钟执行一次 “ ” 字符被用来指定所有的值若” “在分钟的字段域里表示“每分钟” “?”字符只在日期域和星期域中使用。它被用来指定“非明确的值”。当你需要通过在这两个域中的一个来指定一些东西的时候，它是有用的。月份中的日期和星期中的日期这两个元素时互斥的一起应该通过设置一个问号来表明不想设置那个字段。 “-”字符被用来指定一个范围。如：“10-12”在小时域意味着“10点、11点、12点”。 “,”字符被用来指定另外的值。如：“MON,WED,FRI”在星期域里表示”星期一、星期三、星期五”。 “/”字符用于指定增量。如： “0/15”在秒域意思是每分钟的0，15，30和45秒。 “5/15”在分钟域表示每小时的5，20，35和50。 符号“ ”在“/”前面（如： /10）等价于0在“/”前面（如：0/10）。 表达式的每个数值域都是一个有最大值和最小值的集合 如： 秒域和分钟域的集合是0-59，日期域是1-31，月份域是1-12。 字符“/”可以帮助你在每个字符域中取相应的数值。如：“7/6”在月份域的时候只 有当7月的时候才会触发，并不是表示每个6月。 L是‘last’的省略写法可以表示day-of-month和day-of-week域，但在两个字段中的意思不同，例如day-of- month域中表示一个月的最后一天。如果在day-of-week域表示‘7’或者‘SAT’，如果在day-of-week域中前面加上数字，它表示 一个月的最后几天，例如‘6L’就表示一个月的最后一个星期五。 字符“W”只允许日期域出现。这个字符用于指定日期的最近工作日。例如：如果你在日期域中写 “15W”，表示：这个月15号最近的工作日。所以，如果15号是周六，则任务会在14号触发。如果15好是周日，则任务会在周一也就是16号触发。如果 是在日期域填写“1W”即使1号是周六，那么任务也只会在下周一，也就是3号触发，“W”字符指定的最近工作日是不能够跨月份的。字符“W”只能配合一个 单独的数值使用，不能够是一个数字段，如：1-15W是错误的。 “L”和“W”可以在日期域中联合使用，LW表示这个月最后一周的工作日。 字符“#”只允许在星期域中出现。这个字符用于指定本月的某某天。例如：“6#3”表示本月第三周的星期五（6表示星期五，3表示第三周）。“2#1”表示本月第一周的星期一。“4#5”表示第五周的星期三。 字符“C”允许在日期域和星期域出现。这个字符依靠一个指定的“日历”。也就是说这个表达式的值依赖于相关的“日历”的计算结果，如果没有“日历” 关联，则等价于所有包含的“日历”。如：日期域是“5C”表示关联“日历”中第一天，或者这个月开始的第一天的后5天。星期域是“1C”表示关联“日历” 中第一天，或者星期的第一天的后1天，也就是周日的后一天（周一）。 举例:每隔5秒执行一次：”/5 * ?” 每隔1分钟执行一次：”0 /1 ?” 每天23点执行一次：”0 0 23 ?” 每小时执行一次: “0 0 0/1 ?” 每天执行一次: “0 0 0 1/1 * ?” 每天凌晨1点执行一次：”0 0 1 ?” 每月1号凌晨1点执行一次：”0 0 1 1 * ?” 每月最后一天23点执行一次：”0 0 23 L * ?” 每周星期天凌晨1点实行一次：”0 0 1 ? * L” 在26分、29分、33分执行一次：”0 26,29,33 * ?” 每天的0点、13点、18点、21点都执行一次：”0 0 0,13,18,21 ?” 表示在每月的1日的凌晨2点调度任务：”0 0 2 1 ? “ 表示周一到周五每天上午10：15执行作业：”0 15 10 ? * MON-FRI” 表示2002-2006年的每个月的最后一个星期五上午10:15执行：”0 15 10 ? 6L 2002-2006” 4.局限性——@Scheduled的cron无法指定执行的年份若执行以下代码 @Scheduled(cron = &quot;0 18 10 * * ? 2016-2016&quot;) public void testTaskWithDate() { logger.info(&quot;测试2016.定时任务&quot;); } 将会报下面的错误 Cron expression must consist of 6 fields (found 7 in &quot;0 18 10 * * ? 2016-2016&quot;) 错误原因是: /** * Parse the given pattern expression. */ private void parse(String expression) throws IllegalArgumentException { String[] fields = StringUtils.tokenizeToStringArray(expression, &quot; &quot;); if (fields.length != 6) { throw new IllegalArgumentException(String.format(&quot;&quot; + &quot;cron expression must consist of 6 fields (found %d in %s)&quot;, fields.length, expression)); } spring taks 不支持年位定时,但是制定到年份，会存在一个问题，就是在你在过了这个时间后 再启动项目的时候，他会一直报一个memory leak的错误，大概的意思是你的定时任务将永远 不会被执行，导致项目一直启动不了。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"http://yoursite.com/categories/Java/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Scheduled注解","slug":"Scheduled注解","permalink":"http://yoursite.com/tags/Scheduled注解/"},{"name":"cron","slug":"cron","permalink":"http://yoursite.com/tags/cron/"},{"name":"定时任务","slug":"定时任务","permalink":"http://yoursite.com/tags/定时任务/"}]},{"title":"Python应用场景","slug":"Python应用场景","date":"2019-09-04T07:19:52.530Z","updated":"2019-05-20T06:30:41.958Z","comments":true,"path":"2019/09/04/Python应用场景/","link":"","permalink":"http://yoursite.com/2019/09/04/Python应用场景/","excerpt":"Python应用场景Python常被成为胶水语言,能够把其他语言制作的各种模块(尤其是C/C++)轻松联接在一起.常见的一种应用情形是,使用Python快速生成程序的原型(有时是程序的最终界面),然后对其中特别要求的部分,用更合适的语言改写,如3D游戏中的图形渲染模块,性能要求特别高,就用C/C++重写,而后封装为Python可以调用的扩展类库 Python特点(1)使用C语言开发,但没有C语言中的指针等复杂的数据类型(2)具有很强的面向对象特性,且简化了面向对象的实现(3)代码块使用空格或制表符缩进的方式分割代码(4)仅有31个保留字,而且没有分号,begin,end等标记(5)是强类型语言,变量创建后会对应一种数据类型,出现统一表达 式中的不同类型的变量需要做类型转换","text":"Python应用场景Python常被成为胶水语言,能够把其他语言制作的各种模块(尤其是C/C++)轻松联接在一起.常见的一种应用情形是,使用Python快速生成程序的原型(有时是程序的最终界面),然后对其中特别要求的部分,用更合适的语言改写,如3D游戏中的图形渲染模块,性能要求特别高,就用C/C++重写,而后封装为Python可以调用的扩展类库 Python特点(1)使用C语言开发,但没有C语言中的指针等复杂的数据类型(2)具有很强的面向对象特性,且简化了面向对象的实现(3)代码块使用空格或制表符缩进的方式分割代码(4)仅有31个保留字,而且没有分号,begin,end等标记(5)是强类型语言,变量创建后会对应一种数据类型,出现统一表达 式中的不同类型的变量需要做类型转换 Python的应用系统编程:提供API,方便进行系统维护和管理 图形处理:有PIL,TKinter等图形库支持,方便进行图形处理 数学处理：NumPy扩展提供大量与许多标准数学库的接口。 文本处理：python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发 数据库编程：程序员可通过遵循PythonDB-API（数据库应用程序编程接口）规范的模块与 MicrosoftSQLServer，Oracle，Sybase，DB2，MySQL、SQLite等 数据库通信。python自带有一个Gadfly模块，提供了一个完整的SQL环境。 网络编程：提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。很多大规模软件开发计划例如Zope，Mnet及BitTorrent.Google都在广泛地使用它。 Web编程：应用的开发语言，支持最新的XML技术。 多媒体应用：Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。 pymo引擎：PYMO全称为pythonmemoriesoff，是一款运行于SymbianS60V3，Symbian3，S60V5，Symbian3，Android系统上的AVG游戏引擎。因其基于python2.0平台开发，并且适用于创建秋之回忆（memoriesoff）风格的AVG游戏，故命名为PYMO。 黑客编程：python有一个hack的库，内置了你熟悉的或不熟悉的函数，但是缺少成就感。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"菜鸟学习","slug":"菜鸟学习","permalink":"http://yoursite.com/tags/菜鸟学习/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"使用场景","slug":"使用场景","permalink":"http://yoursite.com/tags/使用场景/"}]},{"title":"Python基础知识","slug":"python基础知识","date":"2019-09-04T07:19:52.528Z","updated":"2019-05-20T06:30:24.388Z","comments":true,"path":"2019/09/04/python基础知识/","link":"","permalink":"http://yoursite.com/2019/09/04/python基础知识/","excerpt":"Python 简介Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。 (1)Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。 (2)Python 是交互式语言： 这意味着，您可以在一个Python提示符，直接互动执行写你的程序。 (3)Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。 (3)Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。","text":"Python 简介Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。 (1)Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。 (2)Python 是交互式语言： 这意味着，您可以在一个Python提示符，直接互动执行写你的程序。 (3)Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。 (3)Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。 Python 基础语法1.交互式编程交互式编程不需要创建脚本文件，是通过 Python 解释器的交互模式进来编写代码。 2.脚本式编程通过脚本参数调用解释器开始执行脚本，直到脚本执行完毕。当脚本执行完成后，解释器不再有效。 3.Python 标识符在 Python 里，标识符由字母、数字、下划线组成。在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。Python 中的标识符是区分大小写的。 以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入； 以双下划线开头的 foo 代表类的私有成员；以双下划线开头和结尾的 foo__ 代表 Python 里特殊方法专用的标识，如 init() 代表类的构造函数。 Python 可以同一行显示多条语句，方法是用分号 ; 分开 4.Python 保留字符这些保留字不能用作常数或变数，或任何其他标识符名称。所有 Python 的关键字只包含小写字母。 5.行和缩进学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行 以下代码将会执行错误： #!/usr/bin/python # -*- coding: UTF-8 -*- # 文件名：test.py if True: print \"Answer\" print \"True\" else: print \"Answer\" # 没有严格缩进，在执行时会报错 print \"False\" 6.多行语句Python语句中一般以新行作为语句的结束符。但是我们可以使用斜杠（ \\）将一行的语句分为多行显示，如下所示： total = item_one + \\ item_two + \\ item_three语句中包含 [], {} 或 () 括号就不需要使用多行连接符。如下实例： days = [‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’] 7.Python 引号Python 可以使用引号( ‘ )、双引号( “ )、三引号( ‘’’ 或 “”” ) 来表示字符串，引号的开始与结束必须的相同类型的。 其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。 word = 'word' sentence = \"这是一个句子。\" paragraph = \"\"\"这是一个段落。 包含了多个语句\"\"\" 8.Python注释python中单行注释采用 # 开头 # 第一个注释 print \"Hello, Python!\"; # 第二个注释 9.Python空行函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住：空行也是程序代码的一部分。 同一行显示多条语句Python可以在同一行中使用多条语句，语句之间使用分号(;)分割 10.Print 输出print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号 , 多个语句构成代码组缩进相同的一组语句构成一个代码块，我们称之代码组。 像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。 我们将首行及后面的代码组称为一个子句(clause)。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/tags/基础知识/"},{"name":"菜鸟学习","slug":"菜鸟学习","permalink":"http://yoursite.com/tags/菜鸟学习/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"PHP基础知识","slug":"php基础知识","date":"2019-09-04T07:19:52.525Z","updated":"2019-05-20T06:30:01.984Z","comments":true,"path":"2019/09/04/php基础知识/","link":"","permalink":"http://yoursite.com/2019/09/04/php基础知识/","excerpt":"PHP基础知识PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言.PHP 是免费的，并且使用非常广泛。同时，对于像微软 ASP 这样的竞争者来说，PHP 无疑是另一种高效率的选项。 php适合做网站,做移动app(后端)接口,服务端脚本 PHP 文件(1)PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码 (2)PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器 (3)PHP 文件的默认文件扩展名是 &quot;.php&quot;","text":"PHP基础知识PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言.PHP 是免费的，并且使用非常广泛。同时，对于像微软 ASP 这样的竞争者来说，PHP 无疑是另一种高效率的选项。 php适合做网站,做移动app(后端)接口,服务端脚本 PHP 文件(1)PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码 (2)PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器 (3)PHP 文件的默认文件扩展名是 &quot;.php&quot; PHP 能做什么(1)可以生成动态页面内容 (2)可以创建、打开、读取、写入、关闭服务器上的文件 (3)可以收集表单数据 (4)可以发送和接收 cookies (5)可以添加、删除、修改您的数据库中的数据 (6)可以限制用户访问您的网站上的一些页面 (7)可以加密数据 通过 PHP，您不再限于输出 HTML。您可以输出图像、PDF 文件，甚至 Flash 电影。您还可以输出任意的文本，比如 XHTML 和 XML。 PHP 语法PHP 脚本在服务器上执行，然后将纯 HTML 结果发送回浏览器。 php以 &lt;?php开始,以?&gt;结束,变量以$符开始,后面跟着变量的名称注释:单行注释,//,# 多行注释,/…/通过 PHP，有两种在浏览器输出文本的基础指令:echo 和 print PHP 变量与代数类似，可以给 PHP 变量赋予某个值（x=5）或者表达式（z=x+y）。变量可以是很短的名称（如 x 和 y）或者更具描述性的名称（如 age、carname、totalvolume）。 PHP 变量规则： 变量以 $ 符号开始，后面跟着变量的名称 变量名必须以字母或者下划线字符开始 变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ） 变量名不能包含空格 变量名是区分大小写的（$y 和 $Y 是两个不同的变量） PHP 语句和 PHP 变量都是区分大小写的。 PHP 没有声明变量的命令。 PHP 是一门弱类型语言不必向 PHP 声明该变量的数据类型。PHP 会根据变量的值，自动把变量转换为正确的数据类型。在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。 PHP 变量作用域变量的作用域是脚本中变量可被引用/使用的部分。 PHP 有四种不同的变量作用域：localglobalstaticparameter 1.局部和全局作用域在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问 2.global 关键字global 关键字用于函数内访问全局变量。在函数内调用函数外定义的全局变量，我们需要在函数中的变量前加上 global 关键字 &lt;?php $x=5; $y=10; function myTest() { global $x,$y; $y=$x+$y; } myTest(); echo $y; // 输出 15 ?&gt; PHP 将所有全局变量存储在一个名为 $GLOBALS[index] 的数组中。 index 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。 3.Static 作用域当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。要做到这一点，请在您第一次声明变量时使用 static 关键字 然后，每次调用该函数时，该变量将会保留着函数前一次被调用时的值。注释：该变量仍然是函数的局部变量。 4.参数作用域参数是通过调用代码将值传递给函数的局部变量。参数是在参数列表中声明的，作为函数声明的一部分 PHP echo 和 print 语句echo 和 print 区别:echo - 可以输出一个或多个字符串print - 只允许输出一个字符串，返回值总为 1提示：echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。 函数Arrayarray函数是 PHP 核心的组成部分。无需安装即可使用这些函数 Calendar日历扩展包含了简化不同日历格式间的转换的函数。它是基于 Julian Day Count（儒略日计数），是从公元前 4713 年 1 月 1 日开始计算的。注释：如需在日历格式之间转换，必须首先转换为 Julian Day Count，然后再转换为您需要的日历格式。注释：Julian Day Count（儒略日计数）与 Julian Calendar（儒略历法） 不是一回事！ cURLPHP中使用cURL实现Get和Post请求的方法为了使用PHP的cURL函数，你需要安装 libcurl包。PHP需要使用libcurl 7.0.2-beta 或者更高版本。在PHP 4.2.3 里使用cURL，你需要安装7.9.0或更高版本的libcurl。从PHP 4.3.0开始你需要安装7.9.0或更高版本的libcurl。从PHP 5.0.0开始你需要安装7.10.5或更高版本的libcurl。 要使用PHP的cURL支持你必须在编译PHP时加上–with-curl[=DIR] 选项，DIR为包含lib和include的目录路径。在include目录中必须有一个名为curl，包含了easy.h和curl.h的文件夹。lib文件夹里应该有一个名为libcurl.a的文件。对于PHP 4.3.0你可以配置–with-curlwrappers 使cURL使用URL流。 Date/TimeDate/Time 函数允许您从 PHP 脚本运行的服务器上获取日期和时间。您可以使用 Date/Time 函数通过不同的方式来格式化日期和时间。 注释：这些函数依赖于服务器的本地设置。使用这些函数时请记住要考虑夏令时和闰年。 DirectoryDirectory 函数允许您获得关于目录及其内容的信息。 Error 和 LoggingError 和 Logging 函数允许您对错误进行处理和记录。Error 函数允许用户定义错误处理规则，并修改记录错误的方式。Logging 函数允许用户对应用程序进行日志记录，并把日志消息发送到电子邮件、系统日志或其他的机器。 FilesystemFilesystem 函数允许您访问和操作文件系统。 FilterPHP 过滤器用于对来自非安全来源的数据（比如用户输入）进行验证和过滤。 FTPFTP 函数通过文件传输协议 (FTP) 提供对文件服务器的客户端访问。 FTP 函数用于打开、登录以及关闭连接，同时用于上传、下载、重命名、删除及获取文件服务器上的文件信息。不是所有的 FTP 函数对每个服务器都起作用或返回相同的结果。自 PHP 3 起，FTP 函数可用。 这些函数用于对 FTP 服务器进行细致的访问。如果您仅仅需要对 FTP 服务器进行读写操作，建议使用 Filesystem 函数中的 ftp:// wrapper。 HTTPHTTP 函数允许您在其他输出被发送之前，对由 Web 服务器发送到浏览器的信息进行操作。 LibxmlLibxml 函数和常量与 SimpleXML、XSLT 以及 DOM 函数一起使用 这些函数需要 Libxml 程序包。 在 xmlsoft.org 下载 Mailmail() 函数允许您从脚本中直接发送电子邮件。 MathMath 函数能处理 integer 和 float 范围内的值。 Stringaddcslashes() 返回在指定的字符前添加反斜杠的字符串。….. XML ParserXML 函数允许您解析 XML 文档，但无法对其进行验证。XML 是一种用于标准结构化文档交换的数据格式。您可以在我们的 XML 教程 中找到更多有关 XML 的信息。该扩展使用 Expat XML 解析器。Expat 是一种基于事件的解析器，它把 XML 文档视为一系列事件。当某个事件发生时，它调用一个指定的函数处理它。Expat 是无验证的解析器，忽略任何链接到文档的 DTD。但是，如果文档的形式不好，则会以一个错误消息结束。由于它是一种基于事件，且无验证的解析器，Expat 具有快速并适合 Web 应用程序的特性。XML 解析器函数允许您创建 XML 解析器，并为 XML 事件定义句柄。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/tags/基础知识/"},{"name":"菜鸟学习","slug":"菜鸟学习","permalink":"http://yoursite.com/tags/菜鸟学习/"},{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"消息队列","slug":"MQ","date":"2019-09-04T07:19:52.522Z","updated":"2019-05-20T06:29:36.230Z","comments":true,"path":"2019/09/04/MQ/","link":"","permalink":"http://yoursite.com/2019/09/04/MQ/","excerpt":"消息队列1. 为什么会需要消息队列(MQ) 解耦,冗余,扩展性,灵活性 &amp; 峰值处理能力,可恢复性,顺序保证,缓冲 MQ常用的使用场景：1.进程间通讯和系统间的消息通知,比如分布式系统.2.解耦,如每个团队负责业务的不同模块,各个开发团队可以使用MQ来通信3.在一些高并发场景下,使用MQ的异步特性 消息队列的特点Message Queue把请求的压力保存一下，逐渐释放出来，让处理者按照自己的节奏来处理。Message Queue引入一下新的结点，让系统的可靠性会受Message Queue结点的影响。Message Queue是异步单向的消息。发送消息设计成是不需要等待消息处理的完成。","text":"消息队列1. 为什么会需要消息队列(MQ) 解耦,冗余,扩展性,灵活性 &amp; 峰值处理能力,可恢复性,顺序保证,缓冲 MQ常用的使用场景：1.进程间通讯和系统间的消息通知,比如分布式系统.2.解耦,如每个团队负责业务的不同模块,各个开发团队可以使用MQ来通信3.在一些高并发场景下,使用MQ的异步特性 消息队列的特点Message Queue把请求的压力保存一下，逐渐释放出来，让处理者按照自己的节奏来处理。Message Queue引入一下新的结点，让系统的可靠性会受Message Queue结点的影响。Message Queue是异步单向的消息。发送消息设计成是不需要等待消息处理的完成。 常用的消息队列及使用场景ActiveMQ作为一种消息存储和分发组件,涉及到client和broker端数据交互的方方面面,它不仅要担保消息的 存储安全性,还要提供额外的手段确保消息的分发是可靠的. ActiveMQ消息传送机制Producer客户端使用来发送消息的， Consumer客户端用来消费消息；它们的协同中心就是 ActiveMQ broker,broker也是让producer和consumer调用过程解耦的工具，最终实现了异 步RPC/数据交换的功能。随着ActiveMQ的不断发展，支持了越来越多的特性，也解决开发者在 各种场景下使用ActiveMQ的需求。比如producer支持异步调用；使用flow control机制让 broker协同consumer的消费速率；consumer端可以使用prefetchACK来最大化消息消费的速率； 提供”重发策略”等来提高消息的安全性等 (插入 消息生命周期图片)一条消息从producer端发出之后，一旦被broker正确保存，那么它将会被consumer消费， 然后ACK，broker端才会删除；不过当消息过期或者存储设备溢出时，也会终结它。 JmsJMS是一个用于提供消息服务的技术规范，它制定了在整个消息服务提供过程中的所有数据结构 和交互流程。而MQ则是消息队列服务，是面向消息中间件（MOM）的最终实现，是真正的服务提 供者；MQ的实现可以基于JMS，也可以基于其他规范或标准。 JMS支持两种消息传递模型： 点对点（point-to-point，简称PTP）和发布/订阅（publish/subscribe,简称pub/sub） PTP消息传递模型规定了一条消息只能够传递给一个接收方 Pub/sub消息传递模型允许一条消息传递给多个接收方 点对点模型通过点对点的消息传递模型，一个应用程序可以向另外一个应用程序发送消息。在此传递模型中， 目标类型是队列。消息首先被传送至队列目标，然后从该队列将消息传送至对此队列进行监听的 某个消费者. (插入 点对点图片)一个队列可以关联多个队列发送方和接收方，但一条消息仅传递给一个接收方果多个接收方正在 监听队列上的消息，JMS Provider将根据“先来者优先”的原则确定由哪个接收方接受下一条消 息。如果没有接收方在监听队列，消息将保留在队列中，直至接收方连接到队列为止。这种消息 传递模型是传统意义上的拉模型或轮询模型。在此列模型中，消息不时自动推动给客户端的，而 是要由客户端从队列中请求获得。 ######点对点模型的代码（springboot+jms+activemq） @Service(\"queueproducer\") public class QueueProducer { @Autowired // 也可以注入JmsTemplate，JmsMessagingTemplate对JmsTemplate进行了封装 private JmsMessagingTemplate jmsMessagingTemplate; //发送消息，destination是发送到的队列，message是待发送的消息 @Scheduled(fixedDelay=3000)//每3s执行1次 public void sendMessage(Destination destination, final String message){ jmsMessagingTemplate.convertAndSend(destination, message); } @JmsListener(destination=\"out.queue\") public void consumerMessage(String text){ System.out.println(\"从out.queue队列收到的回复报文为:\"+text); } } Producer的实现@Component public class QueueConsumer2 { // 使用JmsListener配置消费者监听的队列，其中text是接收到的消息 @JmsListener(destination = \"mytest.queue\") //SendTo 该注解的意思是将return回的值，再发送的\"out.queue\"队列中 @SendTo(\"out.queue\") public String receiveQueue(String text) { System.out.println(\"QueueConsumer2收到的报文为:\"+text); return \"return message \"+text; } } Consumer的实现@RunWith(SpringRunner.class) @SpringBootTest public class ActivemqQueueTests { @Autowired private QueueProducer producer; @Test public void contextLoads() throws InterruptedException { Destination destination = new ActiveMQQueue(\"mytest.queue\"); for(int i=0; i&lt;10; i++){ producer.sendMessage(destination, \"myname is Flytiger\" + i); } } } 发布/订阅模型通过发布/订阅消息传递模型，应用程序能够将一条消息发送到多个接收方。在此传送模型中， 目标类型是主题。消息首先被传送至主题目标，然后传送至所有已订阅此主题的或送消费者 (插入 发布或订阅图片)在该模型中，消息会自动广播，消费者无须通过主动请求或轮询主题的方法来获得新的消息。 发布/订阅模型的代码（springboot+jms+activemq）实现如下： @Service(\"topicproducer\") public class TopicProducer { @Autowired // 也可以注入JmsTemplate，JmsMessagingTemplate对JmsTemplate进行了封装 private JmsMessagingTemplate jmsMessagingTemplate; // 发送消息，destination是发送到的队列，message是待发送的消息 @Scheduled(fixedDelay=3000)//每3s执行1次 public void sendMessage(Destination destination, final String message){ jmsMessagingTemplate.convertAndSend(destination, message); } } Producer的实现 @Component public class TopicConsumer2 { // 使用JmsListener配置消费者监听的队列，其中text是接收到的消息 @JmsListener(destination = \"mytest.topic\") public void receiveTopic(String text) { System.out.println(\"TopicConsumer2收到的topic报文为:\"+text); } } Consumer的实现 @RunWith(SpringRunner.class) @SpringBootTest public class ActivemqTopicTests { @Autowired private TopicProducer producer; @Test public void contextLoads() throws InterruptedException { Destination destination = new ActiveMQTopic(\"mytest.topic\"); for(int i=0; i&lt;3; i++){ producer.sendMessage(destination, \"myname is TopicFlytiger\" + i); } } } ActiveMQ优缺点优点：是一个快速的开源消息组件(框架)，支持集群，同等网络，自动检测，TCP，SSL，广播， 持久化，XA，和J2EE1.4容器无缝结合，并且支持轻量级容器和大多数跨语言客户端上的Java 虚拟机。消息异步接受，减少软件多系统集成的耦合度。消息可靠接收，确保消息在中间件可靠 保存，多个消息也可以组成原子事务。 缺点：ActiveMQ默认的配置性能偏低，需要优化配置，但是配置文件复杂，ActiveMQ本身不提 供管理工具；示例代码少；主页上的文档看上去比较全面，但是缺乏一种有效的组织方式，文档 只有片段，用户很难由浅入深进行了解，二、文档整体的专业性太强。在研究阶段可以通过查 maillist、看Javadoc、分析源代码来了解。 RabbitMQ多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理， 而不是每个消费者都收到所有的消息并处理。这种分发方式叫做round-robin(循环的方式)。 当publisher将消息发给queue的过程中，publisher会指明routing key。Direct模式中， Direct Exchange 根据 Routing Key 进行精确匹配，只有对应的 Message Queue 会接受 到消息。Topic模式中Exchange会根据routing key和bindkey进行模式匹配，决定将消息发 送到哪个queue中。 topic和direct只是publisher用来选择发到不同的queue，不是consumer接收消息。一个队 列一个消息只能发送给一个消费者，不然消费者的ack也会有很多，RabbitMQ Server也不好处理 RabbitMQ的消息确认默认情况下，如果Message 已经被某个Consumer正确的接收到了，那么该Message就会被从 queue中移除。当然也可以让同一个Message发送到很多的Consumer。 如果一个queue没被任何的Consumer Subscribe（订阅），那么，如果这个queue有数据到达， 那么这个数据会被cache，不会被丢弃。当有Consumer时，这个数据会被立即发送到这个 Consumer，这个数据被Consumer正确收到时，这个数据就被从queue中删除。 RabbitMQ高可用方案 普通模式(默认) 镜像模式普通模式的基础上，把需要的队列做成镜像队列，存在于多个节点来实现高可用(HA) RabbitMQ功能测试 本次测试依然是RabbitMQ+springboot，首先需要application.properties spring.rabbitmq.host=localhost spring.rabbitmq.port=5672 spring.rabbitmq.username=guest spring.rabbitmq.password=guest 这里的端口是5672，,15672时管理端的端口。pom要添加依赖： &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-amqp&lt;/artifactId> &lt;/dependency> Direct模型Sender的实现： @Component public class Sender { @Autowired private RabbitTemplate rabbitTemplate; public void send(String msg) { this.rabbitTemplate.convertAndSend(\"tiger\", msg); } } Listener和listener2的实现均如下： @Configuration @RabbitListener(queues = \"tiger\") public class Listener { private static final Logger LOGGER = LoggerFactory.getLogger(Listener.class); @Bean public Queue fooQueue() { return new Queue(\"tiger\"); } @RabbitHandler public void process(@Payload String foo) { LOGGER.info(\"Listener: \" + foo); } } 此时多次发送消息时，listener和listener2会按顺序分别收到消息。Listener收到的消息如下： com.example.rabbitmq.Listener : Listener: this is a test com.example.rabbitmq.Listener2 : Listener2: this is a test com.example.rabbitmq.Listener : Listener: this is a test com.example.rabbitmq.Listener2 : Listener2: this is a test com.example.rabbitmq.Listener : Listener: this is a test com.example.rabbitmq.Listener2 : Listener2: this is a test com.example.rabbitmq.Listener : Listener: this is a test com.example.rabbitmq.Listener2 : Listener2: this is a test Topic模型 Sender的实现： @Component public class SenderTopic { @Autowired private RabbitTemplate rabbitTemplate; /*queue的key，用于和routing key 根据binding模式匹配*/ @Bean(name=\"message\") public Queue queueMessage() { return new Queue(\"topic.message\"); } @Bean(name=\"messages\") public Queue queueMessages() { return new Queue(\"topic.messages\"); } @Bean public TopicExchange exchange() { return new TopicExchange(\"exchange\"); } /*设置binding key,此时所有发送到这个exchange的消息， exchange都会根据routing key将消息与@Qualifier定义的queue进行匹配*/ @Bean Binding bindingExchangeMessage(@Qualifier(\"message\") Queue queueMessage, TopicExchange exchange) { return BindingBuilder.bind(queueMessage).to(exchange).with(\"topic.message\"); } @Bean Binding bindingExchangeMessages(@Qualifier(\"messages\") Queue queueMessages, TopicExchange exchange) { return BindingBuilder.bind(queueMessages).to(exchange).with(\"topic.#\");//*表示一个词,#表示零个或多个词 } public void send(String routingKey, String msg) { this.rabbitTemplate.convertAndSend(\"exchange\",routingKey, msg); } } Listener的实现如下： @Configuration @RabbitListener(queues = \"topic.message\")//监听器监听指定的Queue public class ListenerTopic { private static final Logger LOGGER = LoggerFactory.getLogger(ListenerTopic.class); @RabbitHandler public void process(@Payload String foo) { LOGGER.info(\"Listener: \" + foo); } } listener2的实现如下 @Configuration @RabbitListener(queues = \"topic.messages\") public class ListenerTopic2 { private static final Logger LOGGER = LoggerFactory.getLogger(ListenerTopic2.class); @RabbitHandler public void process(@Payload String foo) { LOGGER.info(\"Listener2: \" + foo); } } 发送topic.message会匹配到topic.#和topic.message 两个Receiver都可以收到消息，发送topic.messages（或者top、topic等）只有topic.#可以匹配所有只有Receiver2监听到消息。Fanout模型 @Configuration public class SenderFanout { @Autowired private RabbitTemplate rabbitTemplate; /*queue的key，用于和routing key 根据binding模式匹配*/ @Bean(name=\"Amessage\") public Queue AMessage() { return new Queue(\"fanout.A\"); } @Bean(name=\"Bmessage\") public Queue BMessage() { return new Queue(\"fanout.B\"); } @Bean FanoutExchange fanoutExchange() { return new FanoutExchange(\"fanoutExchange\");//配置广播路由器 } @Bean Binding bindingExchangeA(@Qualifier(\"Amessage\") Queue AMessage,FanoutExchange fanoutExchange) { return BindingBuilder.bind(AMessage).to(fanoutExchange); } @Bean Binding bindingExchangeB(@Qualifier(\"Bmessage\") Queue BMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(BMessage).to(fanoutExchange); } public void send(String msg) { this.rabbitTemplate.convertAndSend(\"fanoutExchange\",\"\", msg); } } @Configuration @RabbitListener(queues = \"fanout.A\")//监听器监听指定的Queue public class ListenerFanout { private static final Logger LOGGER = LoggerFactory.getLogger(ListenerFanout.class); @RabbitHandler public void process(@Payload String foo) { LOGGER.info(\"Listener: \" + foo); } } KafkaKafka是一种分布式的，基于发布/订阅的消息系统。主要设计目标如下： 以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能。 高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条以上消息的传输。 支持Kafka Server间的消息分区，及分布式消费，同时保证每个Partition内的消息顺序传输。 同时支持离线数据处理和实时数据处理。 Scale out：支持在线水平扩展。 (插入 Kafka图片)一个典型的Kafka集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器 日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集 群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管 理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使 用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。 Kafka代理与其它消息系统不同，Kafka代理是无状态的。这意味着消费者必须维护已消费的状态信息。这 些信息由消费者自己维护，代理完全不管。这种设计非常微妙，它本身包含了创新。 从代理删除消息变得很棘手，因为代理并不知道消费者是否已经使用了该消息。Kafka创新性地 解决了这个问题，它将一个简单的基于时间的SLA应用于保留策略。当消息在代理中超过一定时 间后，将会被自动删除。 这种创新设计有很大的好处，消费者可以故意倒回到老的偏移量再次消费数据。这违反了队列 的常见约定，但被证明是许多消费者的基本特征。 从社区活跃度RabbitMQ 、activeM 、ZeroMQ 三者中，综合来看，RabbitMQ 是首选。 持久化消息比较ZeroMq 不支持，ActiveMq 和RabbitMq 都支持。持久化消息主要是指我们机器在不可抗力 因素等情况下宕机了，消息不会丢失的机制。 综合技术实现可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、 插件系统等等。 RabbitMq / Kafka 最好，ActiveMq 次之，ZeroMq 最差。当然ZeroMq 也可以做到，不过 自己必须手动写代码实现，代码量不小。尤其是可靠性中的：持久性、投递确认、发布者证实 和高可用性。 高并发RabbitMQ 最高，原因是它的实现语言是天生具备高并发高可用的erlang 语言 RabbitMQ 和 KafkaRabbitMq 比Kafka 成熟，在可用性上，稳定性上，可靠性上， RabbitMq 胜于 Kafka （理论上）。RabbitMQ使用ProtoBuf序列化消息。极大的方便了Consumer的数据高效处理， 与XML相比，ProtoBuf有以下优势: 1.简单 2.size小了3-10倍 3.速度快了20-100倍 4.易于编程 5.减少了语义的歧义. 使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ 消息队列应用场景异步处理，应用解耦，流量削锋和消息通讯四个场景","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MQ","slug":"MQ","permalink":"http://yoursite.com/tags/MQ/"}]},{"title":"markdown语法","slug":"md语法","date":"2019-09-04T07:19:52.519Z","updated":"2019-05-20T09:04:25.280Z","comments":true,"path":"2019/09/04/md语法/","link":"","permalink":"http://yoursite.com/2019/09/04/md语法/","excerpt":"欢迎使用Markdown编辑器你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。","text":"欢迎使用Markdown编辑器你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 新的改变我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客： 全新的界面设计 ，将会带来全新的写作体验； 在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示； 增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示； 全新的 KaTeX数学公式 语法； 增加了支持甘特图的mermaid语法^1 功能； 增加了 多屏幕编辑 Markdown文章功能； 增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间； 增加了 检查列表 功能。 功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G 合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式强调文本 强调文本 加粗文本 加粗文本 ==标记文本== 删除文本 引用文本 H~2~O is是液体。 2^10^ 运算结果是 1024. 插入链接与图片链接: link. 图片: 带尺寸的图片: 居中的图片: 居中并且带尺寸的图片: 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片. // An highlighted block var foo = 'bar'; 生成一个适合你的列表 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建一个表格一个简单的表格是这么创建的：项目 | Value——– | —–电脑 | $1600手机 | $12导管 | $1 设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右| 第一列 | 第二列 | 第三列 ||:———–:| ————-:|:————-|| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | SmartyPantsSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：| TYPE |ASCII |HTML|—————-|——————————-|—————————–||Single backticks|&#39;Isn&#39;t this fun?&#39; |’Isn’t this fun?’ ||Quotes |&quot;Isn&#39;t this fun?&quot; |”Isn’t this fun?” ||Dashes |-- is en-dash, --- is em-dash|– is en-dash, — is em-dash| 创建一个自定义列表Markdown: Text-to-HTML conversion tool Authors: John: Luke 如何创建一个注脚一个具有注脚的文本。^2 注释也是必不可少的Markdown将文本转换为 HTML。 *[HTML]: 超文本标记语言 KaTeX数学公式您可以使用渲染LaTeX数学表达式 KaTeX: Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\foralln\\in\\mathbb N$ 是通过欧拉积分 $$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.$$ 你可以找到更多关于的信息 LaTeX 数学表达式here. 新的甘特图功能，丰富你的文章gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d 关于 甘特图 语法，参考 这儿, UML 图表可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：: sequenceDiagram 张三 ->> 李四: 你好！李四, 最近怎么样? 李四-->>王五: 你最近怎么样，王五？ 李四--x 张三: 我很好，谢谢! 李四-x 王五: 我很好，谢谢! Note right of 王五: 李四想了很长时间, 文字太长了不适合放在一行. 李四-->>张三: 打量着王五... 张三->>王五: 很好... 王五, 你怎么样? 这将产生一个流程图。: graph LR A[长方形] -- 链接 --> B((圆)) A --> C(圆角长方形) B --> D{菱形} C --> D 关于 Mermaid 语法，参考 这儿, FLowchart流程图我们依旧会支持flowchart的流程图： flowchat st=>start: 开始 e=>end: 结束 op=>operation: 我的操作 cond=>condition: 确认？ st->op->cond cond(yes)->e cond(no)->op 关于 Flowchart流程图 语法，参考 这儿. 导出与导入导出如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。 导入如果你想加载一篇你写过的.md文件或者.html文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，继续你的创作。","categories":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"基本语法","slug":"基本语法","permalink":"http://yoursite.com/tags/基本语法/"}]},{"title":"Java基础","slug":"Java知识","date":"2019-09-04T07:19:52.517Z","updated":"2019-05-20T06:29:11.399Z","comments":true,"path":"2019/09/04/Java知识/","link":"","permalink":"http://yoursite.com/2019/09/04/Java知识/","excerpt":"Java基础1.Java语言的编译过程.Java文件,经过编译,生成.class字节码文件；JVM加载.class并运行.class 2.基本类型8种基本类型:整数类型:byte,short,int 4个字节,long 8个字节浮点型:float,double 8个字节字符型:char 2个字节布尔类型boolean 1个字节 3.三种结构(1)顺序结构:从上往下逐行执行,每句必走(2)分支结构:有条件的执行某语句一次,每句不一定都走 if(1条路) if…else(2条路)if…else if 多条路(3)循环结构:有条件的执行某语句多次,每句不一定都走 循环结构主要找三要素 三要素: (1)循环变量的初始化 (2)循环的条件(以循环变量为基础) (3)循环变量的改变","text":"Java基础1.Java语言的编译过程.Java文件,经过编译,生成.class字节码文件；JVM加载.class并运行.class 2.基本类型8种基本类型:整数类型:byte,short,int 4个字节,long 8个字节浮点型:float,double 8个字节字符型:char 2个字节布尔类型boolean 1个字节 3.三种结构(1)顺序结构:从上往下逐行执行,每句必走(2)分支结构:有条件的执行某语句一次,每句不一定都走 if(1条路) if…else(2条路)if…else if 多条路(3)循环结构:有条件的执行某语句多次,每句不一定都走 循环结构主要找三要素 三要素: (1)循环变量的初始化 (2)循环的条件(以循环变量为基础) (3)循环变量的改变 面向对象1.重载同一个类中,方法名相同,参数列表不同,编译器在编译时会根据方法的签名自动绑定调用的方法 2.构造方法给成员变量赋初值,与类同名,没有返回值类型,在创建对象时自动调用.若不写构造方法,会有默认无参构造方法,若写了,不提供默认方法.构造方法可以重载 this:只能用在方法中,访问变量之前默认有个this,谁调这个方法this就是谁.指代当前对象 3.内存管理:由JVM管理的堆:所有new出来的对象,包含成员变量(实例变量)栈:方法中的局部变量,包括方法的参数方法区:.class字节码文件(方法,静态变量) 局部变量中的变量在栈中装着值(数字) 成员变量中的引用在栈中装着地址,指向堆中的对象 4.继承作用代码复用,extends实现,超类/父类:派生类所共有的属性和行为,派生类/子类:派生类特有的属性和行为.单一继承,传递性 5.重写重新写,覆盖发生在父子类中,方法名称,参数相同,方法体不同重写方法被调用时,看对象的类型(new谁就是谁)两同两小一大超类大,派生类小,void和基本类型返回值类型要相同派生类中的方法访问权限要大于或等于超类的 6.访问控制修饰符(1)数据(变量)私有化(private)(私有的,本类可用)(2)行为(方法)公开化(public)(3)protected:受保护的,本类,子类,通报类可用(4)默认的:同包的,本类的可用 7.static静态变量:由static修饰,属于类的变量,存储在方法区,只有一份,常通过类点名访问何时用:所有对象所共享的数据(图片,视频,音频) 静态方法:由static修饰,属于类的变量,存储在方法区,只有一份,常通过类点名访问实例变量需要对象去点(this指当前对象),静态方法可以被继承,不可被重写.静态方法没有隐式this传递,不能直接访问实例成员何时用:仅与参数相关与对象无关,用static,无论哪个去点结果都一样适用static 静态块:在类被加载期间自动执行,只执行一次,初始化/加载静态资源(图片,音频,视频) 8.抽象方法、类抽象方法：由abstract修饰,只有方法的定义,没有具体的实现(连{}都没有)抽象类也可以不包含抽象方法抽象类:不能new对象(实例化)能声明引用 抽象类需要被继承派生类:重写抽象方法或声明抽象类 包含抽象方法的必须是抽象类 9.内部类成员内部类:在外部类可创建,与实例变量,方法并列,可直接使用外部类的变量和方法 匿名内部类:若想创建一个类的对象,并且对象只被创建一次,此类可不必命名,称为匿名内部类 10.接口是一种数据类型(引用类型),与类平级.由interface定义.接口默认为public只能包含常量和抽象方法.接口不能被实例化(即new对象).接口需要被实现(类似继承)的,实现类(派生类):必须重写接口中的所有抽象方法.一个类可以实现多个接口,用逗号分隔,若又被继承又被实现,先继承后实现.接口可以继承接口,一个接口可以继承多个接口 接口是完全抽象的抽象类 11.多态行为多态:同一类型的引用,指向不同的对象时,有不同的实现. 抽象方法都是多态的对象多态:同一个对象,被造型为不同的类型时,有不同的功能. 想表现多态要向上造型能造型称为的类型:超类+所实现的接口引用类型之间可以强制,成功条件只有两种:(1)引用所指向的对象,就是该类型(2)引用所指向的对象,实现该接口或继承的该类强转若不符合如上条件,则发生ClassCastException类型转换异常在强转之前先通过instanceof来判断引用的对象是否是该类型的引用 12.面向对象三大特征封装:(1)类:封装的是对象的属性和行为(2)方法:封装的是一段特定的业务逻辑功能(3)访问控制修饰符:封装的是具体访问的权限继承:(1)作用:代码复用(2)超类:所有派生类所共有的属性和行为 接口:部分派生类所共有的行为 派生类:派生类所特有的属性和行为(3)传递性,单一继承,多接口实现多态: Object是所有类的鼻祖(1)意义:行为的多态(所有抽象方法都是多态的),对象的多态(所有对象都是多态的)(2)向上造型,强制类型转换,instanceof判断(3)多态的表现形式: 重写:根据对象的不同来实现多态的 重载:根据参数的不同来实现多态的 API为什么hashMap是查询速度最快的数据结构?HashMap之所以是查询速度最快的数据结构,是因为Has和Map本身也是由数组实现,但它根据key的hashcode值计算出的其应在数组的位置并将其存放,这样当根据key查找时也直接根据其hashcode值计算下标快速定位到数组对应位置检索对应的value这样,省去了遍历数组操作,从而不受数据大小影响查询性能.对于Key而言,其HashCode方法与equals方法直接影响其在HashMap内部数组的位置,所有要妥善重写这两个方法,避免在数组中产生链表,否则会影响散列表查询性能.产生链表的原因之一:当两个key的hashcode值相同时,计算对应的数组下标位置相同,但是这两个key的equals不同(不是同一个key,若equals相同map会认为是相同的key,那么就做替换操作)这时就会在数组该位置产生链表.java提供的类都妥善重写了equals与hashcode,包括Object类都满足该重写规则,但是若我们自定义的类若需要重写equals方法时应当一同重写hashcode,这在API手册上有明确说明.重写规则:1.成对重写,即:当我们重写一个类的equals方法时就应当连同重写hashcode方法.2.一致性,即:当两个对象的equals比较为true时,hashcode返回的数字必须相等,反之虽然不是必须的,但是最好保证当两个对象hashcode相等时,equals比较也为true,否则会在HashMap中作为key使用时产生链表,影响查询性能.3.稳定性,即:当参与equals比较的属性值没有发生改变的前提下,多次调用hashcode方法返回的数字不能改变. String与StringBuffer的区别，StringBuffer和StringBuilder的区别是什么？String是不可变的，StringBuffer是可变的；StringBuffer是线程安全的，StringBuilder是非线程安全的。由于字符串链接会自动创建StringBuilder对象，为了避免复杂字符串拼接时候大量创建StringBuilder对象，可以利用StringBuilder优化字符串链接操作。StringBuilder是jdk5之后新增的，其用法与StringBuffer完全一致，但它是线程不安全的，在单线程中最佳，因为其不需要维护线程的安全，因此是最快的。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/tags/基础知识/"},{"name":"内容","slug":"内容","permalink":"http://yoursite.com/tags/内容/"}]},{"title":"Java正则表达式(常用)","slug":"Java正则表达式","date":"2019-09-04T07:19:52.514Z","updated":"2019-05-20T09:01:49.859Z","comments":true,"path":"2019/09/04/Java正则表达式/","link":"","permalink":"http://yoursite.com/2019/09/04/Java正则表达式/","excerpt":"Java正则表达式(常用)正则表达式是个极端强大工具，而且在字符串模式-匹配和字符串模式-替换方面富有弹性。在regex包中，包括了两个类，Pattern(模式类)和Matcher(匹配器类)。Pattern类是用来表达和陈述所要搜索模式的对象，Matcher类是真正影响搜索的对象。另加一个新的例外类，PatternSyntaxException，当遇到不合法的搜索模式时，会抛出例外。 下面整理出来常用的正则表达式。","text":"Java正则表达式(常用)正则表达式是个极端强大工具，而且在字符串模式-匹配和字符串模式-替换方面富有弹性。在regex包中，包括了两个类，Pattern(模式类)和Matcher(匹配器类)。Pattern类是用来表达和陈述所要搜索模式的对象，Matcher类是真正影响搜索的对象。另加一个新的例外类，PatternSyntaxException，当遇到不合法的搜索模式时，会抛出例外。 下面整理出来常用的正则表达式。 校验数字的表达式1 数字：^[0-9]*$ 2 n位的数字：^\\d{n}$ 3 至少n位的数字：^\\d{n,}$ 4 m-n位的数字：^\\d{m,n}$ 5 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 7 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 8 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 11 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 12 非零的负整数：^\\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\\d*$ 13 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 14 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 16 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 17 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 18 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 19 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 校验字符的表达式1 汉字：^[\\u4e00-\\u9fa5]{0,}$ 2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 3 长度为3-20的所有字符：^.{3,20}$ 4 由26个英文字母组成的字符串：^[A-Za-z]+$ 5 由26个大写英文字母组成的字符串：^[A-Z]+$ 6 由26个小写英文字母组成的字符串：^[a-z]+$ 7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 9 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 11 可以输入含有^%&amp;&#39;,;=?$\\&quot;等字符：[^%&amp;&#39;,;=?$\\x22]+ 12 禁止输入含有~的字符：[^~\\x22]+ 特殊需求表达式1 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3 InternetURL：[a-zA-z]+://[^\\s]* 或 ^https://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 5 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 6 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 7 身份证号： 15或18位身份证：^\\d{15}|\\d{18}$ 15位身份证：^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$ 18位身份证：^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{4}$ 8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 12 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 15 钱的输入格式： 16 1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$ 17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 20 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]{2})?$ 21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 24 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 26 中文字符的正则表达式：[\\u4e00-\\u9fa5] 27 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 28 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 29 HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 30 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 32 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) 33 IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"},{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/tags/基础知识/"}]},{"title":"Java常见题目","slug":"Java常见题目","date":"2019-09-04T07:19:52.511Z","updated":"2019-05-20T06:28:46.686Z","comments":true,"path":"2019/09/04/Java常见题目/","link":"","permalink":"http://yoursite.com/2019/09/04/Java常见题目/","excerpt":"Java常见题目1.Springmvc请求处理流程浏览器发送请求,DispatcherServlet接收请求,根据请求路径调用handlerMapping(记录请求路径与控制器的对应关系),handlerMapping返回控制器,dispatcher找到对应controller接收请求并给与响应,把modelandview返回给dispatcher,dispatcher根据视图名,找到视图组件,响应浏览器. 2.Spring IOC、AOP的实现原理IOC：Inversion of control，表示控制反转传统的创建并获取的方式是new构造方法，在使用Spring以后，是类似于getBean()的作法，所以，就由掌握创建并管理对象的主动权，变成了放弃创建并管理对象的主动权，而是只关心如何获取对象，这样的做法就叫做控制反转。AOP是将安全,事务等程序逻辑相对独立的功能抽取出来,利用spring的配置文件将这些功能插入进去,实现了按照方面编程,提高复用性.","text":"Java常见题目1.Springmvc请求处理流程浏览器发送请求,DispatcherServlet接收请求,根据请求路径调用handlerMapping(记录请求路径与控制器的对应关系),handlerMapping返回控制器,dispatcher找到对应controller接收请求并给与响应,把modelandview返回给dispatcher,dispatcher根据视图名,找到视图组件,响应浏览器. 2.Spring IOC、AOP的实现原理IOC：Inversion of control，表示控制反转传统的创建并获取的方式是new构造方法，在使用Spring以后，是类似于getBean()的作法，所以，就由掌握创建并管理对象的主动权，变成了放弃创建并管理对象的主动权，而是只关心如何获取对象，这样的做法就叫做控制反转。AOP是将安全,事务等程序逻辑相对独立的功能抽取出来,利用spring的配置文件将这些功能插入进去,实现了按照方面编程,提高复用性. 3.静态代理,动态代理的区别静态代理:是由程序员创建或由特定工具自动生成源代码,再对其编译,在程序运行前,代理类的.class文件就已经存在.动态代理:在程序运行时,运用反射机制动态创建而成. 4.post请求和get请求的区别get请求:在地址栏输入地址,表单默认的提交方式,会将请求参数显示在地址栏中,不安全.会将请求参数添加到请求行中,只能发送少量数据(大约是2k)post请求:将表单的提交方式改为post,请求的数据不会显示在地址栏中,相对安全,数据会在实体内容中发送,能够发送大量数据. 5.sql注入,跨脚本攻击的处理方式处理sql注入:可以将执行sql对象的statement改成prepareStatement预加载sql执行对象处理跨脚本攻击:输入过滤,对每个用户的输入或者请求首部都要进行过滤,且需要覆盖到所有的输入源.输出过滤,安装防护墙,可以拦截css攻击. 6.mybatis参数使用#和$的区别在mybatis原理中,可以看做参数都在一个map中,使用参数是把它从map中取出用?表示. *#{}可以参考ONGL表达式,${}是sql语句中用来替代某个组成部分,由于sql语法的限制, 无法进行预编译,存在sql注入的风险.需要预编译且替换某个值时用#{}, 若是占位某个语法的组成部分,则使用${}.* 7.springmvc过滤器拦截器是SpringMVC框架中的组件，而过滤器是JavaEE中的组件。拦截器的配置在Spring的配置文件中，更加灵活，可以有多个黑名单，也可以有多个白名单，而过滤器的配置在web.xml中，只有1项黑名单。拦截器是执行在各控制器之前与之后的，而过滤器是执行在所有Servlet之前的 8.url、uri的区别uri统一资源标识符,用来唯一的标识一个资源,web上可用的每种资源如html文档,图片,视频等都是uri来定位的。uri一般由三部组成,访问资源的命名机制、存放资源的主机名、资源自身的名称，由路径表示，着重强调资源。url统一资源定位符，是Internet上用来描述资源的字符串，主要用在各种www客户端和服务器程序上。采用url可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录。uri是url更高层次的抽象，uri属于父类，而url属于uri的子类。 9.servlet、jsp的区别servlet是一种扩展web服务器功能的组件规范，因web服务器只能处理静态资源的请求，即需要事先将html文档准备好，放到web服务器上，不能处理动态资源请求，所以需要servlet的扩展。jsp是sun公司制定的一种动态页面技术规范，是以.jsp为后缀的文件，主要由html标签和少量java代码组成，容器会将jsp转成servlet运行，jsp可以包含html（js，css），java代码片段，隐含对象，指令 10.转发和重定向的区别转发：forward是服务器请求资源,服务器之间访问目标地址的url,把url的响应内容读取过来,然后这些内容再发送给浏览器,浏览器根本不知道服务器发送的内容从哪来,地址栏地址不变.重定向:服务器通知浏览器向某个地址发请求.服务器可以向浏览器发送302状态码和location消息头,该消息头存着重定向的地址,浏览器收到后会向重定向地址发送请求. 12.线程创建的方式，多线程的使用，线程池,mysql索引类型，组合索引，索引失效 线程的创建方式有两种:一.继承extends thread 二.实现runnable接口 多线程的使用:线程是进程的子集,一个进程可以有一个或多个线程,同类的多个线程共享一块内存空间.通常用于一个程序中需要完成多个任务,虽然可以单一线程完成,但多线程速度会更快,如下载.多线程是并发运行的. 线程池:线程池主要由两个作用,控制线程数量和重用线程,即需要创建多个线程或线程频繁使用和销毁时创建线程池. mysql索引类型聚集索引:通过主键创建的索引为聚集索引,一个表只能有一个聚集索引,添加主键约束的表会自动创建聚集索引,它的树状结构保存了数据.非聚集索引:非主键创建的索引,一个表可以有多个,树状结构保存了指针. 组合索引:通过多个字段创建的索引,频繁使用某几个字段作为查询条件的时候,可以为这几个字段创建组合索引. 索引失效:索引无法存储null值 不适合键值较少的列 前导模糊查询不能利用索引 13.in、exsits的区别，左连接、右连接，重载和重写的区别 in和exsits的区别:in可以和子查询一起使用,也可以直接使用,in与子查询一起使用时是针对主查询使用索引,in是把外表和内表作hash连接.exsits一般是与子查询一起使用,会针对子查询的表使用索引,exsits是对外表作loop循环. 左连接和右连接左连接是以jion左边的表为主表,查询所有数据,右边的表只显示有关系的数据,jion前面加left右连接是以jion右边的表为主表,查询所有数据,左边的表只显示有关系的数据,jion前面加right 重载和重写重载:发生在同一个类中,方法名相同,参数列表不同,方法体不同,重载看参数,发生在编译期重写:发生在父子类中,方法名相同,参数列表相同,方法体不同,重写看对象,发生在运行期","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"面试题目","slug":"面试题目","permalink":"http://yoursite.com/tags/面试题目/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java内存模型","slug":"Java内存模型","date":"2019-09-04T07:19:52.508Z","updated":"2019-09-09T09:44:11.736Z","comments":true,"path":"2019/09/04/Java内存模型/","link":"","permalink":"http://yoursite.com/2019/09/04/Java内存模型/","excerpt":"Java内存模型分为:程序计数器(Program Counter Register)、Java栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap)。 1.程序计数器 程序计数器（Program Counter Register），也有称作为PC寄存器。想必学过汇编语言的朋友对程序计数器这个概念并不陌生，在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象.","text":"Java内存模型分为:程序计数器(Program Counter Register)、Java栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap)。 1.程序计数器 程序计数器（Program Counter Register），也有称作为PC寄存器。想必学过汇编语言的朋友对程序计数器这个概念并不陌生，在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象. 2.Java栈 Java栈也称作虚拟机栈（Java Vitual Machine Stack），也就是我们常常所说的栈，跟C语言的数据段中的栈类似。事实上，Java栈是Java方法执行的内存模型。用来存储方法中的局部变量,指向运行时常量池的引用。 3.本地方法栈 本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。 4.方法区 方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。 在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"内存","slug":"内存","permalink":"http://yoursite.com/tags/内存/"},{"name":"简介","slug":"简介","permalink":"http://yoursite.com/tags/简介/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-04T07:19:52.505Z","updated":"2018-10-09T14:17:46.790Z","comments":true,"path":"2019/09/04/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Git和SVN的区别","slug":"git和svn","date":"2019-09-04T07:19:52.503Z","updated":"2019-05-20T06:27:30.435Z","comments":true,"path":"2019/09/04/git和svn/","link":"","permalink":"http://yoursite.com/2019/09/04/git和svn/","excerpt":"Git和SVN的区别(1)最核心的区别Git是分布式的，而Svn不是分布的。能理解这点，上手会很容易，声明一点Git并不是目前唯一的分布式版本控制系统，还有比如Mercurial等，所以说它们差不许多。话说回来Git跟Svn一样有自己的集中式版本库和Server端，但Git更倾向于分布式开发，因为每一个开发人员的电脑上都有一个Local Repository,所以即使没有网络也一样可以Commit，查看历史版本记录，创建项 目分支等操作，等网络再次连接上Push到Server端。","text":"Git和SVN的区别(1)最核心的区别Git是分布式的，而Svn不是分布的。能理解这点，上手会很容易，声明一点Git并不是目前唯一的分布式版本控制系统，还有比如Mercurial等，所以说它们差不许多。话说回来Git跟Svn一样有自己的集中式版本库和Server端，但Git更倾向于分布式开发，因为每一个开发人员的电脑上都有一个Local Repository,所以即使没有网络也一样可以Commit，查看历史版本记录，创建项 目分支等操作，等网络再次连接上Push到Server端。 从上面看GIt真的很棒，但是GIt adds Complexity,刚开始使用会有些疑惑，因为需要建两个Repositories(Local Repositories &amp; Remote Repositories),指令很多，除此之外你需要知道哪些指令在Local Repository，哪些指令在Remote Repository。 (2)Git把内容按元数据方式存储，而SVN是按文件：因为,.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。.git目录的体积大小跟.svn比较，你会发现它们差距很大。 (3)Git没有一个全局版本号，而SVN有：目前为止这是跟SVN相比Git缺少的最大的一个特征。 (4)Git的内容的完整性要优于SVN: GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 (5)Git下载下来后，在OffLine状态下可以看到所有的Log,SVN不可以。 (6)SVN必须先Update才能Commit,忘记了合并时就会出现一些错误，git还是比较少的出现这种情况。 (7)克隆一份全新的目录以同样拥有五个分支来说，SVN是同时复製5个版本的文件,也就是说重复五次同样的动作。而Git只是获取文件的每个版本的 元素，然后只载入主要的分支(master)在我的经验,克隆一个拥有将近一万个提交(commit),五个分支,每个分支有大约1500个文件的 SVN,耗了将近一个小时！而Git只用了区区的1分钟！ (8)版本库（repository):SVN只能有一个指定中央版本库。当这个中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。而 Git可以有无限个版本库。或者，更正确的说法，每一个Git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）发生了什麼事，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！ (9)Git的分支名是可以使用不同名字的。例如：我的本地分支名为OK，而在主要版本库的名字其实是master。 (10))提交（Commit）在SVN，当你提交你的完成品时，它将直接记录到中央版本库。当你发现你的完成品存在严重问题时，你已经无法阻止事情的发生了。如果网路中断，你根本没办法提交！而Git的提交完全属於本地版本库的活动。而你只需“推”（git push）到主要版本库即可。Git的“推”其实是在执行“同步”（Sync）。 总结SVN的特点是简单，只是需要一个放代码的地方时用是OK的。 Git的特点版本控制可以不依赖网络做任何事情，对分支和合并有更好的支持(当然这是开发者最关心的地方)，不过想各位能更好使用它，需要花点时间尝试下。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"}]},{"title":"10个难回答的Java面试题","slug":"10个难回答的Java面试题","date":"2019-09-04T07:19:52.500Z","updated":"2019-08-27T01:49:22.519Z","comments":true,"path":"2019/09/04/10个难回答的Java面试题/","link":"","permalink":"http://yoursite.com/2019/09/04/10个难回答的Java面试题/","excerpt":"1.为什么等待和通知是在 Object 类而不是 Thread 中声明的？１.wait和notify不仅仅是普通方法或同步工具，更重要的是它们是Java中两个线程之间的通信机制 。对语言设计者而言，如果不能通过Java关键字（例如synchronized）实现此通信机制，同时又要确保这个机制对每个对象可用，那么Object类则是正确的声明位置。记住同步和等待、通知是两个不同的领域，不要把它们看成是相同的或相关的。同步是提供互斥并确保Java类的线程安全，而wait和notify是两个线程之间的通信机制。 ２.每个对象都可上锁，这是在Object类而不是Thread类中声明wait和notify的另一个原因。 ３.在Java中为了进入代码的临界区，线程需要锁定并等待锁定，他们不知道哪些线程持有锁，而只是知道锁被某个线程持有，并且他们应该等待取得锁，而不是去了解哪个线程在同步块内，并请求它们释放锁定。","text":"1.为什么等待和通知是在 Object 类而不是 Thread 中声明的？１.wait和notify不仅仅是普通方法或同步工具，更重要的是它们是Java中两个线程之间的通信机制 。对语言设计者而言，如果不能通过Java关键字（例如synchronized）实现此通信机制，同时又要确保这个机制对每个对象可用，那么Object类则是正确的声明位置。记住同步和等待、通知是两个不同的领域，不要把它们看成是相同的或相关的。同步是提供互斥并确保Java类的线程安全，而wait和notify是两个线程之间的通信机制。 ２.每个对象都可上锁，这是在Object类而不是Thread类中声明wait和notify的另一个原因。 ３.在Java中为了进入代码的临界区，线程需要锁定并等待锁定，他们不知道哪些线程持有锁，而只是知道锁被某个线程持有，并且他们应该等待取得锁，而不是去了解哪个线程在同步块内，并请求它们释放锁定。 ４.Java是基于监视器的思想，在Java中，所有对象都有一个监视器。 线程在监视器上等待，为执行等待，我们需要2个参数： 一个线程 一个监视器（任何对象） 在Java设计中，线程不能被指定，它总是运行当前代码的线程。但是，我们可以指定监视器（这是我们称之为等待的对象）。这是一个很好的设计，因为如果我们可以让任何其他线程在所需的监视器上等待，这将导致“入侵”，导致在设计并发程序时会遇到困难。请记住，在Java中，所有在另一个线程的执行中侵入的操作都被弃用了（例如stop方法）。 2.为什么Java中不支持多重继承？假设有一个类A中有方法a(),而类B、类C派生自类A并且也有a()方法,有一个类D多个继承派生自类B、类C，那么引用a（）方法时，编译器不知道是哪个a（）方法.多重继承确实使设计复杂化并在转换、构造函数链接等过程中产生问题。假设你需要多重继承的情况并不多，简单起见，明智的决定是省略它。此外，Java 可以通过使用接口支持单继承来避免这种歧义。由于接口只有方法声明而且没有提供任何实现，因此只有一个特定方法的实现，因此不会有任何歧义 3.为什么Java不支持运算符重载？1)简单性和清晰性。清晰性是Java设计者的目标之一。设计者不是只想复制语言，而是希望拥有一种清晰，真正面向对象的语言。添加运算符重载比没有它肯定会使设计更复杂，并且它可能导致更复杂的编译器, 或减慢 JVM，因为它需要做额外的工作来识别运算符的实际含义，并减少优化的机会, 以保证 Java 中运算符的行为。 2)避免编程错误。Java 不允许用户定义的运算符重载，因为如果允许程序员进行运算符重载，将为同一运算符赋予多种含义，这将使任何开发人员的学习曲线变得陡峭，事情变得更加混乱。据观察，当语言支持运算符重载时，编程错误会增加，从而增加了开发和交付时间。由于 Java 和 JVM 已经承担了大多数开发人员的责任，如在通过提供垃圾收集器进行内存管理时，因为这个功能增加污染代码的机会, 成为编程错误之源, 因此没有多大意义。 3)JVM复杂性。从JVM的角度来看，支持运算符重载使问题变得更加困难。通过更直观，更干净的方式使用方法重载也能实现同样的事情，因此不支持 Java 中的运算符重载是有意义的。与相对简单的 JVM 相比，复杂的 JVM 可能导致 JVM 更慢，并为保证在 Java 中运算符行为的确定性从而减少了优化代码的机会。 4)让开发工具处理更容易。这是在 Java 中不支持运算符重载的另一个好处。省略运算符重载使语言更容易处理，这反过来又更容易开发处理语言的工具，例如 IDE 或重构工具。Java 中的重构工具远胜于C++。 4.为什么 String 在 Java 中是不可变的？在java中考虑到各种因素，需要综合到内存，数据结构以及安全的方面的考虑1)想象字符串池没有使字符串不可变，它根本不可能，因为在字符串池的情况下，一个字符串对象/文字，例如 “Test” 已被许多参考变量引用，因此如果其中任何一个更改了值，其他参数将自动受到影响 2)字符串已被广泛用作许多 Java 类的参数，例如，为了打开网络连接，你可以将主机名和端口号作为字符串传递，你可以将数据库 URL 作为字符串传递, 以打开数据库连接，你可以通过将文件名作为参数传递给 File I/O 类来打开 Java 中的任何文件。如果 String 不是不可变的，这将导致严重的安全威胁，我的意思是有人可以访问他有权授权的任何文件，然后可以故意或意外地更改文件名并获得对该文件的访问权限。由于不变性，你无需担心这种威胁。这个原因也说明了，为什么 String 在 Java 中是最终的，通过使 java.lang.String final，Java设计者确保没有人覆盖 String 类的任何行为。 3)由于 String 是不可变的，它可以安全地共享许多线程，这对于多线程编程非常重要. 并且避免了 Java 中的同步问题，不变性也使得String 实例在 Java 中是线程安全的，这意味着你不需要从外部同步 String 操作。关于 String 的另一个要点是由截取字符串 SubString 引起的内存泄漏，这不是与线程相关的问题，但也是需要注意的。 4)为什么 String 在 Java 中是不可变的另一个原因是允许 String 缓存其哈希码，Java 中的不可变 String 缓存其哈希码，并且不会在每次调用 String 的 hashcode 方法时重新计算，这使得它在 Java 中的 HashMap 中使用的 HashMap 键非常快。简而言之，因为 String 是不可变的，所以没有人可以在创建后更改其内容，这保证了 String 的 hashCode 在多次调用时是相同的。 5)String 不可变的绝对最重要的原因是它被类加载机制使用，因此具有深刻和基本的安全考虑。如果 String 是可变的，加载“java.io.Writer” 的请求可能已被更改为加载 “mil.vogoon.DiskErasingWriter”. 安全性和字符串池是使字符串不可变的主要原因。顺便说一句，上面的理由很好回答另一个Java面试问题: “为什么String在Java中是最终的”。要想是不可变的，你必须是最终的，这样你的子类不会破坏不变性 5.为什么 char 数组比 Java 中的 String 更适合存储密码？1)由于字符串在 Java 中是不可变的，如果你将密码存储为纯文本，它将在内存中可用，直到垃圾收集器清除它. 并且为了可重用性，会存在 String 在字符串池中, 它很可能会保留在内存中持续很长时间，从而构成安全威胁。 由于任何有权访问内存转储的人都可以以明文形式找到密码，这是另一个原因，你应该始终使用加密密码而不是纯文本。由于字符串是不可变的，所以不能更改字符串的内容，因为任何更改都会产生新的字符串，而如果你使用char[]，你就可以将所有元素设置为空白或零。因此，在字符数组中存储密码可以明显降低窃取密码的安全风险。 2)Java 本身建议使用 JPasswordField 的 getPassword() 方法，该方法返回一个 char[] 和不推荐使用的getTex() 方法，该方法以明文形式返回密码，由于安全原因。应遵循 Java 团队的建议, 坚持标准而不是反对它。 3)使用 String 时，总是存在在日志文件或控制台中打印纯文本的风险，但如果使用 Array，则不会打印数组的内容而是打印其内存位置。虽然不是一个真正的原因，但仍然有道理。 6.如何使用双重检查锁定在 Java 中创建线程安全的单例？1) 枚举单例易于书写 这是迄今为止最大的优势,如果你在Java 5之前一直在编写单例, 你知道, 即使双检查锁定, 你仍可以有多个实例。虽然这个问题通过 Java 内存模型的改进已经解决了, 从 Java 5 开始的 volatile 类型变量提供了保证, 但是对于许多初学者来说, 编写起来仍然很棘手。与同步双检查锁定相比,枚举单例实在是太简单了。如果你不相信, 那就比较一下下面的传统双检查锁定单例和枚举单例的代码: 在 Java 中使用枚举的单例 这是我们通常声明枚举的单例的方式,它可能包含实例变量和实例方法,但为了简单起见,我没有使用任何实例方法,只是要注意,如果你使用的实例方法且该方法能改变对象的状态的话, 则需要确保该方法的线程安全。默认情况下,创建枚举实例是线程安全的,但 Enum 上的任何其他方法是否线程安全都是程序员的责任。 /** * 使用 Java 枚举的单例模式示例 */ public enum EasySingleton{ INSTANCE; } 你可以通过EasySingleton.INSTANCE来处理它,这比在单例上调用getInstance()方法容易得多。 具有双检查锁定的单例示例 下面的代码是单例模式中双重检查锁定的示例,此处的 getInstance() 方法检查两次,以查看 INSTANCE 是否为空,这就是为什么它被称为双检查锁定模式,请记住,双检查锁定是代理之前Java 5,但Java5内存模型中易失变量的干扰,它应该工作完美。 /** * 单例模式示例,双重锁定检查 */ public class DoubleCheckedLockingSingleton{ private volatile DoubleCheckedLockingSingleton INSTANCE; private DoubleCheckedLockingSingleton(){} public DoubleCheckedLockingSingleton getInstance(){ if(INSTANCE == null){ synchronized(DoubleCheckedLockingSingleton.class){ //double checking Singleton instance if(INSTANCE == null){ INSTANCE = new DoubleCheckedLockingSingleton(); } } } return INSTANCE; } } 你可以调用DoubleCheckedLockingSingleton.getInstance() 来获取此单例类的访问权限。 现在,只需查看创建延迟加载的线程安全的 Singleton 所需的代码量。使用枚举单例模式, 你可以在一行中具有该模式, 因为创建枚举实例是线程安全的, 并且由 JVM 进行。 人们可能会争辩说,有更好的方法来编写 Singleton 而不是双检查锁定方法, 但每种方法都有自己的优点和缺点, 就像我最喜欢在类加载时创建的静态字段 Singleton, 如下面所示, 但请记住, 这不是一个延迟加载单例: 单例模式用静态工厂方法 在 Java 中影响 Singleton 模式的方法之一,因为 Singleton 实例是静态的,并且最后一个变量在类首次加载到内存时初始化,因此实例的创建本质上是线程安全的。 /** * 单例模式示例与静态工厂方法 */ public class Singleton{ //initailzed during class loading private static final Singleton INSTANCE = new Singleton(); //to prevent creating another instance of Singleton private Singleton(){} public static Singleton getSingleton(){ return INSTANCE; } } 你可以调用 Singleton.getSingleton() 来获取此类的访问权限。 2) 枚举单例自行处理序列化 传统单例的另一个问题是,一旦实现可序列化接口,它们就不再是 Singleton, 因为 readObject() 方法总是返回一个新实例, 就像 Java 中的构造函数一样。通过使用 readResolve() 方法, 通过在以下示例中替换 Singeton 来避免这种情况: //readResolve to prevent another instance of Singleton private Object readResolve(){ return INSTANCE; } 如果 Singleton 类保持内部状态, 这将变得更加复杂, 因为你需要标记为 transient(不被序列化),但使用枚举单例, 序列化由 JVM 进行。 3) 创建枚举实例是线程安全的 如第 1 点所述,因为 Enum 实例的创建在默认情况下是线程安全的, 你无需担心是否要做双重检查锁定。 总之, 在保证序列化和线程安全的情况下,使用两行代码枚举单例模式是在 Java 5 以后的世界中创建 Singleton 的最佳方式。 7. 编写 Java 程序时, 如何在 Java 中创建死锁并修复它？什么是死锁？当两个或多个线程在等待彼此释放所需的资源(锁定)并陷入无限等待即是死锁。它仅在多任务或多线程的情况下发生。 如何检测 Java 中的死锁？如果一个嵌套的同步块，或从一个同步的方法调用其他同步方法, 或试图在不同的对象上获取锁, 就很容易造成死锁。另一种方法是在运行应用程序时实际锁定时找到它, 尝试采取线程转储,在 Linux 中,你可以通过kill -3命令执行此操作, 这将打印应用程序日志文件中所有线程的状态, 并且你可以看到哪个线程被锁定在哪个线程对象上。可以使用 fastthread.io 网站等工具分析该线程转储, 这些工具允许你上载线程转储并对其进行分析。 编写一个将导致死锁的Java程序？ /** * Java 程序通过强制循环等待来创建死锁。 * * */ public class DeadLockDemo { /* * 此方法请求两个锁,第一个字符串,然后整数 */ public void method1() { synchronized (String.class) { System.out.println(\"Aquired lock on String.class object\"); synchronized (Integer.class) { System.out.println(\"Aquired lock on Integer.class object\"); } } } /* * 此方法也请求相同的两个锁,但完全 * 相反的顺序,即首先整数,然后字符串。 * 如果一个线程持有字符串锁,则这会产生潜在的死锁 * 和其他持有整数锁,他们等待对方,永远。 */ public void method2() { synchronized (Integer.class) { System.out.println(\"Aquired lock on Integer.class object\"); synchronized (String.class) { System.out.println(\"Aquired lock on String.class object\"); } } } } 如果 method1() 和 method2() 都由两个或多个线程调用,则存在死锁的可能性, 因为如果线程 1 在执行 method1() 时在 Sting 对象上获取锁, 线程 2 在执行 method2() 时在 Integer 对象上获取锁, 等待彼此释放 Integer 和 String 上的锁以继续进行一步, 但这永远不会发生。 如何避免Java中的死锁？仔细查看上面的代码,那么发现死锁的真正原因不是多个线程, 而是它们请求锁的方式, 如果提供有序访问, 则问题将得到解决。通过避免循环等待，而避免死锁, 而不需要抢占, 这是需要死锁的四个条件之一。 public class DeadLockFixed { /** * 两种方法现在都以相同的顺序请求锁,首先采用整数,然后是 String。 * 你也可以做反向,例如,第一个字符串,然后整数, * 只要两种方法都请求锁定,两者都能解决问题 * 顺序一致。 */ public void method1() { synchronized (Integer.class) { System.out.println(\"Aquired lock on Integer.class object\"); synchronized (String.class) { System.out.println(\"Aquired lock on String.class object\"); } } } public void method2() { synchronized (Integer.class) { System.out.println(\"Aquired lock on Integer.class object\"); synchronized (String.class) { System.out.println(\"Aquired lock on String.class object\"); } } } } 现在没有任何死锁,因为两种方法都按相同的顺序访问 Integer 和 String 类文本上的锁。因此,如果线程 A 在 Integer 对象上获取锁, 则线程 B 不会继续, 直到线程 A 释放 Integer 锁, 即使线程 B 持有 String 锁, 线程 A 也不会被阻止, 因为现在线程 B 不会期望线程 A 释放 Integer 锁以继续。 8. 如果Serializable类包含一个不可序列化的成员，会发生什么？你是如何解决的？什么是 Java 序列化序列化是把对象改成可以存到磁盘或通过网络发送到其他运行中的 Java 虚拟机的二进制格式的过程, 并可以通过反序列化恢复对象状态. Java 序列化API给开发人员提供了一个标准机制, 通过 java.io.Serializable 和 java.io.Externalizable 接口, ObjectInputStream 及ObjectOutputStream 处理对象序列化. Java 程序员可自由选择基于类结构的标准序列化或是他们自定义的二进制格式, 通常认为后者才是最佳实践, 因为序列化的二进制文件格式成为类输出 API的一部分, 可能破坏 Java 中私有和包可见的属性的封装. 如何序列化Java 类只需要实现 java.io.Serializable 接口, JVM 就会把 Object 对象按默认格式序列化.通过实现添加接口来更改类的结构时, 添加或删除任何字段可能会破坏默认序列化, 这可以通过自定义二进制格式使不兼容的可能性最小化, 但仍需要大量的努力来确保向后兼容性 可序列化的方法有多少？如果没有方法,那么可序列化接口的用途是什么？ 可序列化 Serializalbe 接口存在于java.io包中,构成了 Java 序列化机制的核心。它没有任何方法, 在 Java 中也称为标记接口。当类实现 java.io.Serializable 接口时, 它将在 Java 中变得可序列化, 并指示编译器使用 Java 序列化机制序列化此对象。 什么是 serialVersionUID ？如果你不定义这个, 会发生什么？serialVersionUID 是一个 private static final long 型 ID, 当它被印在对象上时, 它通常是对象的哈希码,可以使用 serialver 这个 JDK 工具来查看序列化对象的 serialVersionUID。SerialVerionUID 用于对象的版本控制。也可以在类文件中指定 serialVersionUID。不指定 serialVersionUID的后果是,当你添加或修改类中的任何字段时, 则已序列化类将无法恢复, 因为为新类和旧序列化对象生成的 serialVersionUID 将有所不同。Java 序列化过程依赖于正确的序列化对象恢复状态的,并在序列化对象序列版本不匹配的情况下引发 java.io.InvalidClassException 无效类异常. 序列化时,你希望某些成员不要序列化？你如何实现它？若不希望任何字段是对象的状态的一部分, 然后声明它静态或瞬态根据你的需要, 这样就不会是在 Java 序列化过程中被包含在内。 如果类中的一个成员未实现可序列化接口, 会发生什么情况？在运行时将引发不可序列化异常 NotSerializableException 如果类是可序列化的, 但其超类不是, 则反序列化后从超级类继承的实例变量的状态如何？Java 序列化过程仅在对象层次都是可序列化结构中继续, 即实现 Java 中的可序列化接口, 并且从超级类继承的实例变量的值将通过调用构造函数初始化, 在反序列化过程中不可序列化的超级类。一旦构造函数链接将启动, 就不可能停止, 因此, 即使层次结构中较高的类实现可序列化接口, 也将执行构造函数。 是否可以自定义序列化过程, 或者是否可以覆盖 Java 中的默认序列化过程？可以,对于序列化一个对象需调用 ObjectOutputStream.writeObject(saveThisObject), 并用 ObjectInputStream.readObject() 读取对象, 但 Java 虚拟机为你提供的还有一件事, 是定义这两个方法。如果在类中定义这两种方法, 则 JVM 将调用这两种方法, 而不是应用默认序列化机制。你可以在此处通过执行任何类型的预处理或后处理任务来自定义对象序列化和反序列化的行为。 假设新类的超级类实现可序列化接口, 如何避免新类被序列化？为了避免 Java 序列化,需要在类中实现 writeObject() 和 readObject() 方法, 并且需要从该方法引发不序列化异常NotSerializableException。 在 Java 中的序列化和反序列化过程中使用哪些方法？readObject() 的用法、writeObject()、readExternal() 和 writeExternal()。Java 序列化由java.io.ObjectOutputStream类完成。该类是一个筛选器流, 它封装在较低级别的字节流中, 以处理序列化机制。要通过序列化机制存储任何对象, 我们调用 ObjectOutputStream.writeObject(savethisobject), 并反序列化该对象, 我们称之为 ObjectInputStream.readObject()方法。调用以 writeObject() 方法在 java 中触发序列化过程。关于 readObject() 方法, 需要注意的一点很重要一点是, 它用于从持久性读取字节, 并从这些字节创建对象, 并返回一个对象, 该对象需要类型强制转换为正确的类型。 假设有一个类,它序列化并存储在持久性中, 然后修改了该类以添加新字段。如果对已序列化的对象进行反序列化, 会发生什么情况？ 这取决于类是否具有其自己的 serialVersionUID。正如我们从上面的问题知道, 如果我们不提供 serialVersionUID, 则 Java 编译器将生成它, 通常它等于对象的哈希代码。通过添加任何新字段, 有可能为该类新版本生成的新 serialVersionUID 与已序列化的对象不同, 在这种情况下, Java 序列化 API 将引发 java.io.InvalidClassException, 因此建议在代码中拥有自己的 serialVersionUID, 并确保在单个类中始终保持不变。 9. 为什么Java中 wait 方法需要在 synchronized 的方法中调用？ 用 Java 中的 synchronized 方法或 synchronized 块调用 Java 中的 wait()，notify() 或 notifyAll() 方法来避免： 1) Java 会抛出 IllegalMonitorStateException，如果我们不调用来自同步上下文的wait()，notify()或者notifyAll()方法。 2) Javac 中 wait 和 notify 方法之间的任何潜在竞争条件。 10.你能用Java覆盖静态方法吗？如果我在子类中创建相同的方法是编译时错误？你不能覆盖Java中的静态方法，因为方法覆盖基于运行时的动态绑定，静态方法在编译时使用静态绑定进行绑定。虽然可以在子类中声明一个具有相同名称和方法签名的方法，看起来可以在Java中覆盖静态方法，但实际上这是方法隐藏。Java不会在运行时解析方法调用，并且根据用于调用静态方法的 Object 类型，将调用相应的方法。这意味着如果你使用父类的类型来调用静态方法，那么原始静态将从父类中调用，另一方面如果你使用子类的类型来调用静态方法，则会调用来自子类的方法。简而言之，你无法在Java中覆盖静态方法。如果你使用像Eclipse或Netbeans这样的Java IDE，它们将显示警告静态方法应该使用类名而不是使用对象来调用，因为静态方法不能在Java中重写。 /** * * Java program which demonstrate that we can not override static method in Java. * Had Static method can be overridden, with Super class type and sub class object * static method from sub class would be called in our example, which is not the case. */ public class CanWeOverrideStaticMethod { public static void main(String args[]) { Screen scrn = new ColorScreen(); //if we can override static , this should call method from Child class scrn.show(); //IDE will show warning, static method should be called from classname } } class Screen{ /* * public static method which can not be overridden in Java */ public static void show(){ System.out.printf(\"Static method from parent class\"); } } class ColorScreen extends Screen{ /* * static method of same name and method signature as existed in super * class, this is not method overriding instead this is called * method hiding in Java */ public static void show(){ System.err.println(\"Overridden static method in Child Class in Java\"); } } 输出: Static method from parent class 此输出确认你无法覆盖Java中的静态方法，并且静态方法基于类型信息而不是基于Object进行绑定。如果要覆盖静态mehtod，则会调用子类或 ColorScreen 中的方法。这一切都在讨论中我们可以覆盖Java中的静态方法。我们已经确认没有，我们不能覆盖静态方法，我们只能在Java中隐藏静态方法。创建具有相同名称和mehtod签名的静态方法称为Java隐藏方法。IDE将显示警告：”静态方法应该使用类名而不是使用对象来调用”, 因为静态方法不能在Java中重写。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"面试题目","slug":"面试题目","permalink":"http://yoursite.com/tags/面试题目/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"难点","slug":"难点","permalink":"http://yoursite.com/tags/难点/"}]}]}